(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["rosbag"] = factory();
	else
		root["rosbag"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/node/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/BagReader.js":
/*!**************************!*\
  !*** ./src/BagReader.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BagReader; });
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./header */ "./src/header.js");
/* harmony import */ var _nmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nmerge */ "./src/nmerge.js");
/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./record */ "./src/record.js");
/* harmony import */ var _TimeUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeUtil */ "./src/TimeUtil.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.




const HEADER_READAHEAD = 4096;
const HEADER_OFFSET = 13; // BagReader is a lower level interface for reading specific sections & chunks
// from a rosbag file - generally it is consumed through the Bag class, but
// can be useful to use directly for efficiently accessing raw pieces from
// within the bag

class BagReader {
  constructor(filelike) {
    _defineProperty(this, "_lastReadResult", void 0);

    _defineProperty(this, "_file", void 0);

    _defineProperty(this, "_lastChunkInfo", void 0);

    this._file = filelike;
    this._lastChunkInfo = undefined;
  }

  verifyBagHeader(callback, next) {
    this._file.read(0, HEADER_OFFSET, (error, buffer) => {
      if (error || !buffer) {
        return callback(error || new Error("Missing both error and buffer"));
      }

      if (this._file.size() < HEADER_OFFSET) {
        return callback(new Error("Missing file header."));
      }

      if (buffer.toString() !== "#ROSBAG V2.0\n") {
        return callback(new Error("Cannot identify bag format."));
      }

      next();
    });
  } // reads the header block from the rosbag file
  // generally you call this first
  // because you need the header information to call readConnectionsAndChunkInfo


  readHeader(callback) {
    this.verifyBagHeader(callback, () => {
      return this._file.read(HEADER_OFFSET, HEADER_READAHEAD, (error, buffer) => {
        if (error || !buffer) {
          return callback(error || new Error("Missing both error and buffer"));
        }

        const read = buffer.length;

        if (read < 8) {
          return callback(new Error(`Record at position ${HEADER_OFFSET} is truncated.`));
        }

        const headerLength = buffer.readInt32LE(0);

        if (read < headerLength + 8) {
          return callback(new Error(`Record at position ${HEADER_OFFSET} header too large: ${headerLength}.`));
        }

        try {
          const header = this.readRecordFromBuffer(buffer, HEADER_OFFSET, _record__WEBPACK_IMPORTED_MODULE_2__["BagHeader"]);
          return callback(null, header);
        } catch (e) {
          return callback(new Error(`Could not read header from rosbag file buffer - ${e.message}`));
        }
      });
    });
  } // promisified version of readHeader


  readHeaderAsync() {
    return new Promise((resolve, reject) => this.readHeader((err, header) => err || !header ? reject(err) : resolve(header)));
  } // reads connection and chunk information from the bag
  // you'll generally call this after reading the header so you can get
  // connection metadata and chunkInfos which allow you to seek to individual
  // chunks & read them


  readConnectionsAndChunkInfo(fileOffset, connectionCount, chunkCount, callback) {
    this._file.read(fileOffset, this._file.size() - fileOffset, (err, buffer) => {
      if (err || !buffer) {
        return callback(err || new Error("Missing both error and buffer"));
      }

      if (connectionCount === 0) {
        return callback(null, {
          connections: [],
          chunkInfos: []
        });
      }

      const connections = this.readRecordsFromBuffer(buffer, connectionCount, fileOffset, _record__WEBPACK_IMPORTED_MODULE_2__["Connection"]);
      const connectionBlockLength = connections[connectionCount - 1].end - connections[0].offset;
      const chunkInfos = this.readRecordsFromBuffer(buffer.slice(connectionBlockLength), chunkCount, fileOffset + connectionBlockLength, _record__WEBPACK_IMPORTED_MODULE_2__["ChunkInfo"]);

      if (chunkCount > 0) {
        for (let i = 0; i < chunkCount - 1; i++) {
          chunkInfos[i].nextChunk = chunkInfos[i + 1];
        }

        chunkInfos[chunkCount - 1].nextChunk = null;
      }

      return callback(null, {
        connections,
        chunkInfos
      });
    });
  } // promisified version of readConnectionsAndChunkInfo


  readConnectionsAndChunkInfoAsync(fileOffset, connectionCount, chunkCount) {
    return new Promise((resolve, reject) => {
      this.readConnectionsAndChunkInfo(fileOffset, connectionCount, chunkCount, (err, result) => err || !result ? reject(err) : resolve(result));
    });
  } // read individual raw messages from the bag at a given chunk
  // filters to a specific set of connection ids, start time, & end time
  // generally the records will be of type MessageData


  readChunkMessages(chunkInfo, connections, startTime, endTime, decompress, callback) {
    const start = startTime || {
      sec: 0,
      nsec: 0
    };
    const end = endTime || {
      sec: Number.MAX_VALUE,
      nsec: Number.MAX_VALUE
    };
    const conns = connections || chunkInfo.connections.map(connection => {
      return connection.conn;
    });
    this.readChunk(chunkInfo, decompress, (error, result) => {
      if (error || !result) {
        return callback(error || new Error("Missing both error and result"));
      }

      const chunk = result.chunk;
      const indices = {};
      result.indices.forEach(index => {
        indices[index.conn] = index;
      });
      const presentConnections = conns.filter(conn => {
        return indices[conn] !== undefined;
      });
      const iterables = presentConnections.map(conn => {
        // $FlowFixMe https://github.com/facebook/flow/issues/1163
        return indices[conn].indices[Symbol.iterator]();
      });
      const iter = Object(_nmerge__WEBPACK_IMPORTED_MODULE_1__["default"])((a, b) => _TimeUtil__WEBPACK_IMPORTED_MODULE_3__["compare"](a.time, b.time), ...iterables);
      const entries = [];
      let item = iter.next();

      while (!item.done) {
        const {
          value
        } = item;
        item = iter.next();

        if (!value || _TimeUtil__WEBPACK_IMPORTED_MODULE_3__["isGreaterThan"](start, value.time)) {
          continue;
        }

        if (_TimeUtil__WEBPACK_IMPORTED_MODULE_3__["isGreaterThan"](value.time, end)) {
          break;
        }

        entries.push(value);
      }

      const messages = entries.map(entry => {
        return this.readRecordFromBuffer(chunk.data.slice(entry.offset), chunk.dataOffset, _record__WEBPACK_IMPORTED_MODULE_2__["MessageData"]);
      });
      return callback(null, messages);
    });
  } // promisified version of readChunkMessages


  readChunkMessagesAsync(chunkInfo, connections, startTime, endTime, decompress) {
    return new Promise((resolve, reject) => {
      this.readChunkMessages(chunkInfo, connections, startTime, endTime, decompress, (err, messages) => err || !messages ? reject(err) : resolve(messages));
    });
  } // reads a single chunk record && its index records given a chunkInfo


  readChunk(chunkInfo, decompress, callback) {
    // if we're reading the same chunk a second time return the cached version
    // to avoid doing decompression on the same chunk multiple times which is
    // expensive
    if (chunkInfo === this._lastChunkInfo && this._lastReadResult) {
      // always callback async, even if we have the result
      // https://oren.github.io/blog/zalgo.html
      const lastReadResult = this._lastReadResult;
      return setImmediate(() => callback(null, lastReadResult));
    }

    const {
      nextChunk
    } = chunkInfo;
    const readLength = nextChunk ? nextChunk.chunkPosition - chunkInfo.chunkPosition : this._file.size() - chunkInfo.chunkPosition;

    this._file.read(chunkInfo.chunkPosition, readLength, (err, buffer) => {
      if (err || !buffer) {
        return callback(err || new Error("Missing both error and buffer"));
      }

      const chunk = this.readRecordFromBuffer(buffer, chunkInfo.chunkPosition, _record__WEBPACK_IMPORTED_MODULE_2__["Chunk"]);
      const {
        compression
      } = chunk;

      if (compression !== "none") {
        const decompressFn = decompress[compression];

        if (!decompressFn) {
          return callback(new Error(`Unsupported compression type ${chunk.compression}`));
        }

        const result = decompressFn(chunk.data, chunk.size);
        chunk.data = result;
      }

      const indices = this.readRecordsFromBuffer(buffer.slice(chunk.length), chunkInfo.count, chunkInfo.chunkPosition + chunk.length, _record__WEBPACK_IMPORTED_MODULE_2__["IndexData"]);
      this._lastChunkInfo = chunkInfo;
      this._lastReadResult = {
        chunk,
        indices
      };
      return callback(null, this._lastReadResult);
    });
  } // reads count records from a buffer starting at fileOffset


  readRecordsFromBuffer(buffer, count, fileOffset, cls) {
    const records = [];
    let bufferOffset = 0;

    for (let i = 0; i < count; i++) {
      const record = this.readRecordFromBuffer(buffer.slice(bufferOffset), fileOffset + bufferOffset, cls);
      bufferOffset += record.end - record.offset;
      records.push(record);
    }

    return records;
  } // read an individual record from a buffer


  readRecordFromBuffer(buffer, fileOffset, cls) {
    const headerLength = buffer.readInt32LE(0);
    const headerFields = Object(_header__WEBPACK_IMPORTED_MODULE_0__["parseHeader"])(buffer.slice(4, 4 + headerLength), cls);
    const dataOffset = 4 + headerLength + 4;
    const dataLength = buffer.readInt32LE(4 + headerLength);
    const data = buffer.slice(dataOffset, dataOffset + dataLength);
    const record = new cls(headerFields, data);
    record.offset = fileOffset;
    record.dataOffset = record.offset + 4 + headerLength + 4;
    record.end = record.dataOffset + dataLength;
    record.length = record.end - record.offset;
    return record;
  }

}

/***/ }),

/***/ "./src/MessageReader.js":
/*!******************************!*\
  !*** ./src/MessageReader.js ***!
  \******************************/
/*! exports provided: MessageReader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageReader", function() { return MessageReader; });
/* harmony import */ var int53__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! int53 */ "int53");
/* harmony import */ var int53__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(int53__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fields */ "./src/fields.js");
/* harmony import */ var _parseMessageDefinition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parseMessageDefinition */ "./src/parseMessageDefinition.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.




// this has hard-coded buffer reading functions for each
// of the standard message types http://docs.ros.org/api/std_msgs/html/index-msg.html
// eventually custom types decompose into these standard types
class StandardTypeReader {
  constructor(buffer) {
    _defineProperty(this, "buffer", void 0);

    _defineProperty(this, "offset", void 0);

    _defineProperty(this, "view", void 0);

    _defineProperty(this, "_decoder", void 0);

    _defineProperty(this, "_decoderStatus", "NOT_INITIALIZED");

    this.buffer = buffer;
    this.offset = 0;
    this.view = new DataView(buffer.buffer, buffer.byteOffset);
  }

  _intializeTextDecoder() {
    if (typeof global.TextDecoder === "undefined") {
      this._decoderStatus = "NOT_AVAILABLE";
      return;
    }

    try {
      this._decoder = new global.TextDecoder("ascii");
      this._decoderStatus = "INITIALIZED";
    } catch (e) {
      // Swallow the error if we don't support ascii encoding.
      this._decoderStatus = "NOT_AVAILABLE";
    }
  }

  json() {
    const resultString = this.string();

    try {
      return JSON.parse(resultString);
    } catch (_unused) {
      return `Could not parse ${resultString}`;
    }
  }

  string() {
    const len = this.int32();
    const codePoints = new Uint8Array(this.buffer.buffer, this.buffer.byteOffset + this.offset, len);
    this.offset += len; // if the string is relatively short we can use apply, but longer strings can benefit from the speed of TextDecoder.

    if (codePoints.length < 1000) {
      return String.fromCharCode.apply(null, codePoints);
    } // Use TextDecoder if it is available and supports the "ascii" encoding.


    if (this._decoderStatus === "NOT_INITIALIZED") {
      this._intializeTextDecoder();
    }

    if (this._decoder) {
      // TextDecoder does not support Uint8Arrays that are backed by SharedArrayBuffer, so copy the array here.
      // SharedArrayBuffer support has been added to the spec, but most browsers have not implemented this change.
      // See spec change: https://github.com/whatwg/encoding/pull/182
      // Track browser support here: https://github.com/whatwg/encoding/pull/182#issuecomment-539932294
      const input = codePoints.buffer instanceof global.SharedArrayBuffer ? new Uint8Array(codePoints) : codePoints;
      return this._decoder.decode(input);
    } // Otherwise, use string concatentation.


    let data = "";

    for (let i = 0; i < len; i++) {
      data += String.fromCharCode(codePoints[i]);
    }

    return data;
  }

  bool() {
    return this.uint8() !== 0;
  }

  int8() {
    return this.view.getInt8(this.offset++);
  }

  uint8() {
    return this.view.getUint8(this.offset++);
  }

  typedArray(len, arrayType) {
    const arrayLength = len == null ? this.uint32() : len;
    const data = new arrayType(this.view.buffer, this.offset + this.view.byteOffset, arrayLength);
    this.offset += arrayLength;
    return data;
  }

  int16() {
    const result = this.view.getInt16(this.offset, true);
    this.offset += 2;
    return result;
  }

  uint16() {
    const result = this.view.getUint16(this.offset, true);
    this.offset += 2;
    return result;
  }

  int32() {
    const result = this.view.getInt32(this.offset, true);
    this.offset += 4;
    return result;
  }

  uint32() {
    const result = this.view.getUint32(this.offset, true);
    this.offset += 4;
    return result;
  }

  float32() {
    const result = this.view.getFloat32(this.offset, true);
    this.offset += 4;
    return result;
  }

  float64() {
    const result = this.view.getFloat64(this.offset, true);
    this.offset += 8;
    return result;
  }

  int64() {
    const offset = this.offset;
    this.offset += 8;
    return int53__WEBPACK_IMPORTED_MODULE_0___default.a.readInt64LE(this.buffer, offset);
  }

  uint64() {
    const offset = this.offset;
    this.offset += 8;
    return int53__WEBPACK_IMPORTED_MODULE_0___default.a.readUInt64LE(this.buffer, offset);
  }

  time() {
    const offset = this.offset;
    this.offset += 8;
    return Object(_fields__WEBPACK_IMPORTED_MODULE_1__["extractTime"])(this.buffer, offset);
  }

  duration() {
    const offset = this.offset;
    this.offset += 8;
    return Object(_fields__WEBPACK_IMPORTED_MODULE_1__["extractTime"])(this.buffer, offset);
  }

}

const findTypeByName = (types, name) => {
  const matches = types.filter(type => type.name === name);

  if (matches.length !== 1) {
    throw new Error(`Expected 1 top level type definition for '${name}' but found ${matches.length}.`);
  }

  return matches[0];
};

const friendlyName = name => name.replace(/\//g, "_");

const createParser = (types, typeName, freeze) => {
  const topLevelTypes = types.filter(type => type.name === typeName);

  if (topLevelTypes.length !== 1) {
    throw new Error("multiple top-level types");
  }

  const [topLevelType] = topLevelTypes;
  const nestedTypes = types.filter(type => type.name !== typeName);

  const constructorBody = type => {
    const readerLines = [];
    type.definitions.forEach(def => {
      if (def.isConstant) {
        return;
      }

      if (def.isArray) {
        if (def.type === "uint8" || def.type === "int8") {
          const arrayType = def.type === "uint8" ? "Uint8Array" : "Int8Array";
          readerLines.push(`this.${def.name} = reader.typedArray(${String(def.arrayLength)}, ${arrayType});`);
          return;
        }

        const lenField = `length_${def.name}`; // set a variable pointing to the parsed fixed array length
        // or read the byte indicating the dynamic length

        readerLines.push(`var ${lenField} = ${def.arrayLength ? def.arrayLength : "reader.uint32();"}`); // only allocate an array if there is a length - skips empty allocations

        const arrayName = `this.${def.name}`; // allocate the new array to a fixed length since we know it ahead of time

        readerLines.push(`${arrayName} = new Array(${lenField})`); // start the for-loop

        readerLines.push(`for (var i = 0; i < ${lenField}; i++) {`); // if the sub type is complex we need to allocate it and parse its values

        if (def.isComplex) {
          const defType = findTypeByName(types, def.type); // recursively call the constructor for the sub-type

          readerLines.push(`  ${arrayName}[i] = new Record.${friendlyName(defType.name)}(reader);`);
        } else {
          // if the subtype is not complex its a simple low-level reader operation
          readerLines.push(`  ${arrayName}[i] = reader.${def.type}();`);
        }

        readerLines.push("}"); // close the for-loop
      } else if (def.isComplex) {
        const defType = findTypeByName(types, def.type);
        readerLines.push(`this.${def.name} = new Record.${friendlyName(defType.name)}(reader);`);
      } else {
        readerLines.push(`this.${def.name} = reader.${def.type}();`);
      }
    });

    if (freeze) {
      readerLines.push("Object.freeze(this);");
    }

    return readerLines.join("\n    ");
  };

  let js = `
  var Record = function (reader) {
    ${constructorBody(topLevelType)}
  };\n`;
  nestedTypes.forEach(t => {
    js += `
  Record.${friendlyName(t.name)} = function(reader) {
    ${constructorBody(t)}
  };\n`;
  });
  js += `
  return function read(reader) {
    return new Record(reader);
  };`;

  let _read;

  try {
    _read = eval(`(function buildReader() { ${js} })()`);
  } catch (e) {
    console.error("error building parser:", js); // eslint-disable-line no-console

    throw e;
  }

  return function (buffer) {
    const reader = new StandardTypeReader(buffer);
    return _read(reader);
  };
};

class MessageReader {
  // takes an object message definition and returns
  // a message reader which can be used to read messages based
  // on the message definition
  constructor(definitions, typeName, options = {}) {
    _defineProperty(this, "reader", void 0);

    let parsedDefinitions = definitions;

    if (typeof parsedDefinitions === "string") {
      // eslint-disable-next-line no-console
      console.warn("Passing string message defintions to MessageReader is deprecated. Instead call `parseMessageDefinition` on it and pass in the resulting parsed message definition object.");
      parsedDefinitions = Object(_parseMessageDefinition__WEBPACK_IMPORTED_MODULE_2__["parseMessageDefinition"])(parsedDefinitions, typeName);
    }

    this.reader = createParser(parsedDefinitions, typeName, !!options.freeze);
  }

  readMessage(buffer) {
    return this.reader(buffer);
  }

}

/***/ }),

/***/ "./src/MessageWriter.js":
/*!******************************!*\
  !*** ./src/MessageWriter.js ***!
  \******************************/
/*! exports provided: MessageWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageWriter", function() { return MessageWriter; });
/* harmony import */ var int53__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! int53 */ "int53");
/* harmony import */ var int53__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(int53__WEBPACK_IMPORTED_MODULE_0__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.


// write a Time object to a buffer.
function writeTime(time, buffer, offset) {
  buffer.writeUInt32LE(time.sec, offset);
  buffer.writeUInt32LE(time.nsec, offset + 4);
}

class StandardTypeOffsetCalculator {
  constructor() {
    _defineProperty(this, "offset", 0);
  }

  // Returns the current offset and increments the next offset by `byteCount`.
  _incrementAndReturn(byteCount) {
    const offset = this.offset;
    this.offset += byteCount;
    return offset;
  } // These are not actually used in the StandardTypeWriter, so they must be kept in sync with those implementations.


  json(value) {
    return this.string(JSON.stringify(value));
  } // The following are used in the StandardTypeWriter.


  string(value) {
    // int32 length
    const length = 4 + value.length;
    return this._incrementAndReturn(length);
  }

  bool() {
    return this.uint8();
  }

  int8() {
    return this._incrementAndReturn(1);
  }

  uint8() {
    return this._incrementAndReturn(1);
  }

  int16() {
    return this._incrementAndReturn(2);
  }

  uint16() {
    return this._incrementAndReturn(2);
  }

  int32() {
    return this._incrementAndReturn(4);
  }

  uint32() {
    return this._incrementAndReturn(4);
  }

  float32() {
    return this._incrementAndReturn(4);
  }

  float64() {
    return this._incrementAndReturn(8);
  }

  int64() {
    return this._incrementAndReturn(8);
  }

  uint64() {
    return this._incrementAndReturn(8);
  }

  time() {
    return this._incrementAndReturn(8);
  }

  duration() {
    return this._incrementAndReturn(8);
  }

} // this has hard-coded buffer writing functions for each
// of the standard message types http://docs.ros.org/api/std_msgs/html/index-msg.html
// eventually custom types decompose into these standard types


class StandardTypeWriter {
  constructor(buffer) {
    _defineProperty(this, "buffer", void 0);

    _defineProperty(this, "view", void 0);

    _defineProperty(this, "offsetCalculator", void 0);

    this.buffer = buffer;
    this.view = new DataView(buffer.buffer, buffer.byteOffset);
    this.offsetCalculator = new StandardTypeOffsetCalculator();
  }

  json(value) {
    this.string(JSON.stringify(value));
  }

  string(value) {
    const stringOffset = this.offsetCalculator.string(value);
    this.view.setInt32(stringOffset, value.length, true);
    this.buffer.write(value, stringOffset + 4, value.length, "ascii");
  }

  bool(value) {
    this.uint8(value ? 1 : 0);
  }

  int8(value) {
    this.view.setInt8(this.offsetCalculator.int8(), value);
  }

  uint8(value) {
    this.view.setUint8(this.offsetCalculator.uint8(), value);
  }

  int16(value) {
    this.view.setInt16(this.offsetCalculator.int16(), value, true);
  }

  uint16(value) {
    this.view.setUint16(this.offsetCalculator.uint16(), value, true);
  }

  int32(value) {
    this.view.setInt32(this.offsetCalculator.int32(), value, true);
  }

  uint32(value) {
    this.view.setUint32(this.offsetCalculator.uint32(), value, true);
  }

  float32(value) {
    this.view.setFloat32(this.offsetCalculator.float32(), value, true);
  }

  float64(value) {
    this.view.setFloat64(this.offsetCalculator.float64(), value, true);
  }

  int64(value) {
    int53__WEBPACK_IMPORTED_MODULE_0___default.a.writeInt64LE(value, this.buffer, this.offsetCalculator.int64());
  }

  uint64(value) {
    int53__WEBPACK_IMPORTED_MODULE_0___default.a.writeUInt64LE(value, this.buffer, this.offsetCalculator.uint64());
  }

  time(time) {
    writeTime(time, this.buffer, this.offsetCalculator.time());
  }

  duration(time) {
    writeTime(time, this.buffer, this.offsetCalculator.time());
  }

}

const findTypeByName = (types, name) => {
  const ret = types.find(type => type.name === name);

  if (ret == null) {
    throw new Error(`Type '${name}' but not found.`);
  }

  return ret;
};

const friendlyName = name => name.replace(/\//g, "_");

function createWriterAndSizeCalculator(types, typeName) {
  const topLevelType = findTypeByName(types, typeName);
  const nestedTypes = types.filter(type => type.name !== typeName);

  const constructorBody = (type, argName) => {
    const lines = [];
    type.definitions.forEach(def => {
      if (def.isConstant) {
        return;
      } // Accesses the field we are currently writing. Pulled out for easy reuse.


      const accessMessageField = `message["${def.name}"]`;

      if (def.isArray) {
        const lenField = `length_${def.name}`; // set a variable pointing to the parsed fixed array length
        // or write the byte indicating the dynamic length

        if (def.arrayLength) {
          lines.push(`var ${lenField} = ${def.arrayLength};`);
        } else {
          lines.push(`var ${lenField} = ${accessMessageField}.length;`);
          lines.push(`${argName}.uint32(${lenField});`);
        } // start the for-loop


        lines.push(`for (var i = 0; i < ${lenField}; i++) {`); // if the sub type is complex we need to allocate it and parse its values

        if (def.isComplex) {
          const defType = findTypeByName(types, def.type); // recursively call the function for the sub-type

          lines.push(`  ${friendlyName(defType.name)}(${argName}, ${accessMessageField}[i]);`);
        } else {
          // if the subtype is not complex its a simple low-level operation
          lines.push(`  ${argName}.${def.type}(${accessMessageField}[i]);`);
        }

        lines.push("}"); // close the for-loop
      } else if (def.isComplex) {
        const defType = findTypeByName(types, def.type);
        lines.push(`${friendlyName(defType.name)}(${argName}, ${accessMessageField});`);
      } else {
        // Call primitives directly.
        lines.push(`${argName}.${def.type}(${accessMessageField});`);
      }
    });
    return lines.join("\n    ");
  };

  let writerJs = "";
  let calculateSizeJs = "";
  nestedTypes.forEach(t => {
    writerJs += `
  function ${friendlyName(t.name)}(writer, message) {
    ${constructorBody(t, "writer")}
  };\n`;
    calculateSizeJs += `
  function ${friendlyName(t.name)}(offsetCalculator, message) {
    ${constructorBody(t, "offsetCalculator")}
  };\n`;
  });
  writerJs += `
  return function write(writer, message) {
    ${constructorBody(topLevelType, "writer")}
    return writer.buffer;
  };`;
  calculateSizeJs += `
  return function calculateSize(offsetCalculator, message) {
    ${constructorBody(topLevelType, "offsetCalculator")}
    return offsetCalculator.offset;
  };`;

  let _write;

  let _calculateSize;

  try {
    _write = eval(`(function buildWriter() { ${writerJs} })()`);
  } catch (e) {
    console.error("error building writer:", writerJs); // eslint-disable-line no-console

    throw e;
  }

  try {
    _calculateSize = eval(`(function buildSizeCalculator() { ${calculateSizeJs} })()`);
  } catch (e) {
    console.error("error building size calculator:", calculateSizeJs); // eslint-disable-line no-console

    throw e;
  }

  return {
    writer: function (message, buffer) {
      const writer = new StandardTypeWriter(buffer);
      return _write(writer, message);
    },

    bufferSizeCalculator(message) {
      const offsetCalculator = new StandardTypeOffsetCalculator();
      return _calculateSize(offsetCalculator, message);
    }

  };
}

class MessageWriter {
  // takes an object string message definition and returns
  // a message writer which can be used to write messages based
  // on the message definition
  constructor(definitions, typeName) {
    _defineProperty(this, "writer", void 0);

    _defineProperty(this, "bufferSizeCalculator", void 0);

    const {
      writer,
      bufferSizeCalculator
    } = createWriterAndSizeCalculator(definitions, typeName);
    this.writer = writer;
    this.bufferSizeCalculator = bufferSizeCalculator;
  } // Calculates the buffer size needed to write this message in bytes.


  calculateBufferSize(message) {
    return this.bufferSizeCalculator(message);
  } // bufferToWrite is optional - if it is not provided, a buffer will be generated.


  writeMessage(message, bufferToWrite) {
    let buffer = bufferToWrite;

    if (!buffer) {
      const bufferSize = this.calculateBufferSize(message);
      buffer = Buffer.allocUnsafe(bufferSize);
    }

    return this.writer(message, buffer);
  }

}

/***/ }),

/***/ "./src/ReadResult.js":
/*!***************************!*\
  !*** ./src/ReadResult.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ReadResult; });
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.
// represents a result passed to the callback from the high-level call:
// bag.readMessages({ opts: any }, callback: (ReadResult) => void) => Promise<void>
class ReadResult {
  constructor(topic, message, timestamp, data, chunkOffset, totalChunks, freeze) {
    _defineProperty(this, "topic", void 0);

    _defineProperty(this, "message", void 0);

    _defineProperty(this, "timestamp", void 0);

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "chunkOffset", void 0);

    _defineProperty(this, "totalChunks", void 0);

    // string: the topic the message was on
    this.topic = topic; // any: the parsed body of the message based on connection.messageDefinition

    this.message = message; // time: the timestamp of the message

    this.timestamp = timestamp; // buffer: raw buffer data of the message

    this.data = data; // the offset of the currently read chunk

    this.chunkOffset = chunkOffset; // the total number of chunks in the read operation

    this.totalChunks = totalChunks;

    if (freeze) {
      Object.freeze(timestamp);
      Object.freeze(this);
    }
  }

}

/***/ }),

/***/ "./src/TimeUtil.js":
/*!*************************!*\
  !*** ./src/TimeUtil.js ***!
  \*************************/
/*! exports provided: fromDate, toDate, compare, isLessThan, isGreaterThan, areSame, add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromDate", function() { return fromDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDate", function() { return toDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compare", function() { return compare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLessThan", function() { return isLessThan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGreaterThan", function() { return isGreaterThan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areSame", function() { return areSame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.
function fromDate(date) {
  const sec = Math.floor(date.getTime() / 1000);
  const nsec = date.getMilliseconds() * 1e6;
  return {
    sec,
    nsec
  };
}
function toDate(time) {
  return new Date(time.sec * 1e3 + time.nsec / 1e6);
} // compare two times, returning a negative value if the right is greater
// or a positive value if the left is greater or 0 if the times are equal
// useful to supply to Array.prototype.sort

function compare(left, right) {
  const secDiff = left.sec - right.sec;
  return secDiff || left.nsec - right.nsec;
} // returns true if the left time is less than the right time, otherwise false

function isLessThan(left, right) {
  return this.compare(left, right) < 0;
} // returns true if the left time is greater than the right time, otherwise false

function isGreaterThan(left, right) {
  return this.compare(left, right) > 0;
} // returns true if both times have the same number of seconds and nanoseconds

function areSame(left, right) {
  return left.sec === right.sec && left.nsec === right.nsec;
}

function toString(time) {
  return `{${time.sec}, ${time.nsec}}`;
} // computes the sum of two times or durations and returns a new time
// throws an exception if the resulting time is negative


function add(left, right) {
  const durationNanos = left.nsec + right.nsec;
  const secsFromNanos = Math.floor(durationNanos / 1e9);
  const newSecs = left.sec + right.sec + secsFromNanos;
  const remainingDurationNanos = durationNanos % 1e9; // use Math.abs here to prevent -0 when there is exactly 1 second of negative nanoseconds passed in

  const newNanos = Math.abs(Math.sign(remainingDurationNanos) === -1 ? 1e9 + remainingDurationNanos : remainingDurationNanos);
  const result = {
    sec: newSecs,
    nsec: newNanos
  };

  if (result.sec < 0 || result.nsec < 0) {
    throw new Error(`Invalid time: ${toString(result)} produced from TimeUtil.add(${toString(left)}, ${toString(right)}})`);
  }

  return result;
}

/***/ }),

/***/ "./src/bag.js":
/*!********************!*\
  !*** ./src/bag.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bag; });
/* harmony import */ var _BagReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BagReader */ "./src/BagReader.js");
/* harmony import */ var _MessageReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MessageReader */ "./src/MessageReader.js");
/* harmony import */ var _ReadResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReadResult */ "./src/ReadResult.js");
/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./record */ "./src/record.js");
/* harmony import */ var _TimeUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TimeUtil */ "./src/TimeUtil.js");
/* harmony import */ var _parseMessageDefinition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parseMessageDefinition */ "./src/parseMessageDefinition.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.






// the high level rosbag interface
// create a new bag by calling:
// `const bag = await Bag.open('./path-to-file.bag')` in node or
// `const bag = await Bag.open(files[0])` in the browser
//
// after that you can consume messages by calling
// `await bag.readMessages({ topics: ['/foo'] },
//    (result) => console.log(result.topic, result.message))`
class Bag {
  // you can optionally create a bag manually passing in a bagReader instance
  constructor(bagReader) {
    _defineProperty(this, "reader", void 0);

    _defineProperty(this, "header", void 0);

    _defineProperty(this, "connections", void 0);

    _defineProperty(this, "chunkInfos", void 0);

    _defineProperty(this, "startTime", void 0);

    _defineProperty(this, "endTime", void 0);

    this.reader = bagReader;
  } // eslint-disable-next-line no-unused-vars


  // if the bag is manually created with the constructor, you must call `await open()` on the bag
  // generally this is called for you if you're using `const bag = await Bag.open()`
  async open() {
    this.header = await this.reader.readHeaderAsync();
    const {
      connectionCount,
      chunkCount,
      indexPosition
    } = this.header;
    const result = await this.reader.readConnectionsAndChunkInfoAsync(indexPosition, connectionCount, chunkCount);
    this.connections = {};
    result.connections.forEach(connection => {
      this.connections[connection.conn] = connection;
    });
    this.chunkInfos = result.chunkInfos;

    if (chunkCount > 0) {
      // Get the earliest startTime among all chunks
      this.startTime = this.chunkInfos.map(x => x.startTime).reduce((prev, current) => _TimeUtil__WEBPACK_IMPORTED_MODULE_4__["compare"](prev, current) <= 0 ? prev : current); // Get the latest endTime among all chunks

      this.endTime = this.chunkInfos.map(x => x.endTime).reduce((prev, current) => _TimeUtil__WEBPACK_IMPORTED_MODULE_4__["compare"](prev, current) > 0 ? prev : current);
    }
  }

  async readMessages(opts, callback) {
    const connections = this.connections;
    const startTime = opts.startTime || {
      sec: 0,
      nsec: 0
    };
    const endTime = opts.endTime || {
      sec: Number.MAX_VALUE,
      nsec: Number.MAX_VALUE
    };
    const topics = opts.topics || Object.keys(connections).map(id => {
      return connections[id].topic;
    });
    const filteredConnections = Object.keys(connections).filter(id => {
      return topics.indexOf(connections[id].topic) !== -1;
    }).map(id => +id);
    const {
      decompress = {}
    } = opts; // filter chunks to those which fall within the time range we're attempting to read

    const chunkInfos = this.chunkInfos.filter(info => {
      return _TimeUtil__WEBPACK_IMPORTED_MODULE_4__["compare"](info.startTime, endTime) <= 0 && _TimeUtil__WEBPACK_IMPORTED_MODULE_4__["compare"](startTime, info.endTime) <= 0;
    });

    function parseMsg(msg, chunkOffset) {
      const connection = connections[msg.conn];
      const {
        topic,
        type
      } = connection;
      const {
        data,
        time: timestamp
      } = msg;
      let message = null;

      if (!opts.noParse) {
        // lazily create a reader for this connection if it doesn't exist
        connection.reader = connection.reader || new _MessageReader__WEBPACK_IMPORTED_MODULE_1__["MessageReader"](Object(_parseMessageDefinition__WEBPACK_IMPORTED_MODULE_5__["parseMessageDefinition"])(connection.messageDefinition, type), type, {
          freeze: opts.freeze
        });
        message = connection.reader.readMessage(data);
      }

      return new _ReadResult__WEBPACK_IMPORTED_MODULE_2__["default"](topic, message, timestamp, data, chunkOffset, chunkInfos.length, opts.freeze);
    }

    for (let i = 0; i < chunkInfos.length; i++) {
      const info = chunkInfos[i];
      const messages = await this.reader.readChunkMessagesAsync(info, filteredConnections, startTime, endTime, decompress);
      messages.forEach(msg => callback(parseMsg(msg, i)));
    }
  }

}

_defineProperty(Bag, "open", file => {
  throw new Error("This method should have been overridden based on the environment. Make sure you are correctly importing the node or web version of Bag.");
});

/***/ }),

/***/ "./src/fields.js":
/*!***********************!*\
  !*** ./src/fields.js ***!
  \***********************/
/*! exports provided: extractFields, extractTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFields", function() { return extractFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractTime", function() { return extractTime; });
// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.
// reads through a buffer and extracts { [key: string]: value: string }
// pairs - the buffer is expected to have length prefixed utf8 strings
// with a '=' separating the key and value
const EQUALS_CHARCODE = "=".charCodeAt(0);
function extractFields(buffer) {
  if (buffer.length < 4) {
    throw new Error("Header fields are truncated.");
  }

  let i = 0;
  const fields = {};

  while (i < buffer.length) {
    const length = buffer.readInt32LE(i);
    i += 4;

    if (i + length > buffer.length) {
      throw new Error("Header fields are corrupt.");
    } // Passing a number into "indexOf" explicitly to avoid Buffer polyfill
    // slow path. See issue #87.


    const field = buffer.slice(i, i + length);
    const index = field.indexOf(EQUALS_CHARCODE);

    if (index === -1) {
      throw new Error("Header field is missing equals sign.");
    }

    fields[field.slice(0, index).toString()] = field.slice(index + 1);
    i += length;
  }

  return fields;
} // reads a Time object out of a buffer at the given offset

function extractTime(buffer, offset) {
  const sec = buffer.readUInt32LE(offset);
  const nsec = buffer.readUInt32LE(offset + 4);
  return {
    sec,
    nsec
  };
}

/***/ }),

/***/ "./src/header.js":
/*!***********************!*\
  !*** ./src/header.js ***!
  \***********************/
/*! exports provided: parseHeader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseHeader", function() { return parseHeader; });
/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fields */ "./src/fields.js");
/* harmony import */ var _record__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./record */ "./src/record.js");
// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.

 // given a buffer parses out the record within the buffer
// based on the opcode type bit

function parseHeader(buffer, cls) {
  const fields = Object(_fields__WEBPACK_IMPORTED_MODULE_0__["extractFields"])(buffer);

  if (fields.op === undefined) {
    throw new Error("Header is missing 'op' field.");
  }

  const opcode = fields.op.readUInt8(0);

  if (opcode !== cls.opcode) {
    throw new Error(`Expected ${cls.name} (${cls.opcode}) but found ${opcode}`);
  }

  return fields;
}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TimeUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TimeUtil */ "./src/TimeUtil.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "TimeUtil", function() { return _TimeUtil__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _bag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bag */ "./src/bag.js");
/* empty/unused harmony star reexport *//* harmony import */ var _BagReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BagReader */ "./src/BagReader.js");
/* empty/unused harmony star reexport *//* harmony import */ var _MessageReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MessageReader */ "./src/MessageReader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessageReader", function() { return _MessageReader__WEBPACK_IMPORTED_MODULE_3__["MessageReader"]; });

/* harmony import */ var _MessageWriter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MessageWriter */ "./src/MessageWriter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessageWriter", function() { return _MessageWriter__WEBPACK_IMPORTED_MODULE_4__["MessageWriter"]; });

/* harmony import */ var _parseMessageDefinition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parseMessageDefinition */ "./src/parseMessageDefinition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rosPrimitiveTypes", function() { return _parseMessageDefinition__WEBPACK_IMPORTED_MODULE_5__["rosPrimitiveTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseMessageDefinition", function() { return _parseMessageDefinition__WEBPACK_IMPORTED_MODULE_5__["parseMessageDefinition"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types */ "./src/types.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_6__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_6__) if(["TimeUtil","default","MessageReader","MessageWriter","rosPrimitiveTypes","parseMessageDefinition","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _types__WEBPACK_IMPORTED_MODULE_6__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fields */ "./src/fields.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFields", function() { return _fields__WEBPACK_IMPORTED_MODULE_7__["extractFields"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractTime", function() { return _fields__WEBPACK_IMPORTED_MODULE_7__["extractTime"]; });

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.










/***/ }),

/***/ "./src/nmerge.js":
/*!***********************!*\
  !*** ./src/nmerge.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! heap */ "heap");
/* harmony import */ var heap__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(heap__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.


function nmerge(key, ...iterables) {
  const heap = new heap__WEBPACK_IMPORTED_MODULE_0___default.a((a, b) => {
    return key(a.value, b.value);
  });

  for (let i = 0; i < iterables.length; i++) {
    const {
      value,
      done
    } = iterables[i].next();

    if (!done) {
      heap.push({
        i,
        value
      });
    }
  }

  return {
    next: () => {
      if (heap.empty()) {
        return {
          done: true
        };
      }

      const {
        i
      } = heap.front();
      const next = iterables[i].next();

      if (next.done) {
        return {
          value: heap.pop().value,
          done: false
        };
      }

      return {
        value: heap.replace({
          i,
          value: next.value
        }).value,
        done: false
      };
    }
  };
}

/* harmony default export */ __webpack_exports__["default"] = (nmerge);

/***/ }),

/***/ "./src/node/index.js":
/*!***************************!*\
  !*** ./src/node/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reader", function() { return Reader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "open", function() { return open; });
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ "buffer");
/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index */ "./src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimeUtil", function() { return _index__WEBPACK_IMPORTED_MODULE_2__["TimeUtil"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessageReader", function() { return _index__WEBPACK_IMPORTED_MODULE_2__["MessageReader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessageWriter", function() { return _index__WEBPACK_IMPORTED_MODULE_2__["MessageWriter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseMessageDefinition", function() { return _index__WEBPACK_IMPORTED_MODULE_2__["parseMessageDefinition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rosPrimitiveTypes", function() { return _index__WEBPACK_IMPORTED_MODULE_2__["rosPrimitiveTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractFields", function() { return _index__WEBPACK_IMPORTED_MODULE_2__["extractFields"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extractTime", function() { return _index__WEBPACK_IMPORTED_MODULE_2__["extractTime"]; });

/* harmony import */ var _bag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bag */ "./src/bag.js");
/* harmony import */ var _BagReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../BagReader */ "./src/BagReader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BagReader", function() { return _BagReader__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types */ "./src/types.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_5__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_5__) if(["Reader","TimeUtil","BagReader","MessageReader","MessageWriter","open","parseMessageDefinition","rosPrimitiveTypes","extractFields","extractTime","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _types__WEBPACK_IMPORTED_MODULE_5__[key]; }) }(__WEBPACK_IMPORT_KEY__));
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.




 // reader using nodejs fs api

class Reader {
  constructor(filename) {
    _defineProperty(this, "_filename", void 0);

    _defineProperty(this, "_fd", void 0);

    _defineProperty(this, "_size", void 0);

    _defineProperty(this, "_buffer", void 0);

    this._filename = filename;
    this._fd = undefined;
    this._size = 0;
    this._buffer = buffer__WEBPACK_IMPORTED_MODULE_0__["Buffer"].allocUnsafe(0);
  } // open a file for reading


  _open(cb) {
    fs__WEBPACK_IMPORTED_MODULE_1__["stat"](this._filename, (error, stat) => {
      if (error) {
        return cb(error);
      }

      return fs__WEBPACK_IMPORTED_MODULE_1__["open"](this._filename, "r", (err, fd) => {
        if (err) {
          return cb(err);
        }

        this._fd = fd;
        this._size = stat.size;
        return cb(null);
      });
    });
  }

  close(cb) {
    if (this._fd != null) {
      fs__WEBPACK_IMPORTED_MODULE_1__["close"](this._fd, cb);
    }
  } // read length (bytes) starting from offset (bytes)
  // callback(err, buffer)


  read(offset, length, cb) {
    if (this._fd == null) {
      return this._open(err => {
        return err ? cb(err) : this.read(offset, length, cb);
      });
    }

    if (length > this._buffer.byteLength) {
      this._buffer = buffer__WEBPACK_IMPORTED_MODULE_0__["Buffer"].alloc(length);
    }

    return fs__WEBPACK_IMPORTED_MODULE_1__["read"](this._fd, this._buffer, 0, length, offset, (err, bytes, buff) => {
      return err ? cb(err) : cb(null, buff);
    });
  } // return the size of the file


  size() {
    return this._size;
  }

}

const open = async filename => {
  if (typeof filename !== "string") {
    throw new Error("Expected filename to be a string. Make sure you are correctly importing the node or web version of Bag.");
  }

  const bag = new _bag__WEBPACK_IMPORTED_MODULE_3__["default"](new _BagReader__WEBPACK_IMPORTED_MODULE_4__["default"](new Reader(filename)));
  await bag.open();
  return bag;
};

_bag__WEBPACK_IMPORTED_MODULE_3__["default"].open = open;


/* harmony default export */ __webpack_exports__["default"] = (_bag__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./src/parseMessageDefinition.js":
/*!***************************************!*\
  !*** ./src/parseMessageDefinition.js ***!
  \***************************************/
/*! exports provided: rosPrimitiveTypes, parseMessageDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rosPrimitiveTypes", function() { return rosPrimitiveTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseMessageDefinition", function() { return parseMessageDefinition; });
// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.
// Set of built-in ros types. See http://wiki.ros.org/msg#Field_Types
const rosPrimitiveTypes = new Set(["string", "bool", "int8", "uint8", "int16", "uint16", "int32", "uint32", "float32", "float64", "int64", "uint64", "time", "duration", "json"]);

function normalizeType(type) {
  // Normalize deprecated aliases.
  let normalizedType = type;

  if (type === "char") {
    normalizedType = "uint8";
  }

  if (type === "byte") {
    normalizedType = "int8";
  }

  return normalizedType;
} // represents a single line in a message definition type
// e.g. 'string name' 'CustomType[] foo' 'string[3] names'


function newArrayDefinition(type, name, arrayLength) {
  const normalizedType = normalizeType(type);
  return {
    type: normalizedType,
    name,
    isArray: true,
    arrayLength: arrayLength === null ? undefined : arrayLength,
    isComplex: !rosPrimitiveTypes.has(normalizedType)
  };
}

function newDefinition(type, name) {
  const normalizedType = normalizeType(type);
  return {
    type: normalizedType,
    name,
    isArray: false,
    isComplex: !rosPrimitiveTypes.has(normalizedType)
  };
}

const tokenizeLine = line => line.replace(/#.*/gi, "").split(" ").filter(word => word);

const buildNamedType = (lines, typeName) => {
  const definitions = [];
  lines.forEach(({
    isJson,
    line
  }) => {
    // remove comments and extra whitespace from each line
    const splits = tokenizeLine(line);

    if (!splits[1]) {
      return;
    } // consume comments


    const type = splits[0].trim();
    const name = splits[1].trim();

    if (name.indexOf("=") > -1 || splits.indexOf("=") > -1) {
      // constant type parsing
      const matches = line.match(/(\S+)\s*=\s*(.*)\s*/);

      if (!matches) {
        throw new Error("Malformed line: " + line);
      }

      let value = matches[2];

      if (type !== "string") {
        // handle special case of python bool values
        value = value.replace(/True/gi, "true");
        value = value.replace(/False/gi, "false");

        try {
          value = JSON.parse(value.replace(/\s*#.*/g, ""));
        } catch (error) {
          // eslint-disable-next-line no-console
          console.warn(`Error in this constant definition: ${line}`);
          throw error;
        }

        if (type === "bool") {
          value = Boolean(value);
        }
      }

      if (type.includes("int") && value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {
        // eslint-disable-next-line no-console
        console.warn(`Found integer constant outside safe integer range: ${line}`);
      }

      definitions.push({
        type: normalizeType(type),
        name: matches[1],
        isConstant: true,
        value
      });
    } else if (type.indexOf("]") === type.length - 1) {
      // array type parsing
      const typeSplits = type.split("[");
      const baseType = typeSplits[0];
      const len = typeSplits[1].replace("]", "");
      definitions.push(newArrayDefinition(baseType, name, len ? parseInt(len, 10) : undefined));
    } else {
      definitions.push(newDefinition(isJson ? "json" : type, name));
    }
  });
  return {
    name: typeName,
    definitions
  };
};

const buildType = lines => {
  if (lines.length === 0) {
    throw new Error("Empty message definition.");
  }

  if (!lines[0].line.startsWith("MSG: ")) {
    throw new Error(`Malformed message definition name: ${lines[0].line}`);
  }

  const typeName = tokenizeLine(lines[0].line)[1].trim();
  return buildNamedType(lines.slice(1), typeName);
};

const findTypeByName = (types, name, rosPackage) => {
  const fullName = name.includes("/") ? name : name === "Header" ? "std_msgs/Header" : `${rosPackage}/${name}`;
  const matches = types.filter(type => type.name === fullName);

  if (matches.length !== 1) {
    throw new Error(`Expected 1 top level type definition for '${name}' but found ${matches.length}, ${JSON.stringify({
      fullName,
      k: types.map(type => type.name)
    })}`);
  }

  return matches[0];
}; // Given a raw message definition string, parse it into an object representation.
// Type names in all positions are always fully-qualified.
//
// Example return value:
// [{
//   name: "foo_msgs/Bar",
//   definitions: [
//     {
//       arrayLength: undefined,
//       isArray: false,
//       isComplex: false,
//       name: "name",
//       type: "string",
//     }, ...
//   ],
// }, ... ]
//
// See unit tests for more examples.


function parseMessageDefinition(messageDefinition, typeName) {
  // read all the lines and remove empties
  const allLines = messageDefinition.split("\n").map(line => line.trim()).filter(line => line);
  let definitionLines = [];
  const types = [];
  let nextDefinitionIsJson = false; // group lines into individual definitions

  allLines.forEach(line => {
    // ignore comment lines unless they start with #pragma rosbag_parse_json
    if (line.startsWith("#")) {
      if (line.startsWith("#pragma rosbag_parse_json")) {
        nextDefinitionIsJson = true;
      }

      return;
    } // definitions are split by equal signs


    if (line.startsWith("==")) {
      nextDefinitionIsJson = false;
      const definition = types.length === 0 ? buildNamedType(definitionLines, typeName) : buildType(definitionLines);
      types.push(definition);
      definitionLines = [];
    } else {
      definitionLines.push({
        isJson: nextDefinitionIsJson,
        line
      });
      nextDefinitionIsJson = false;
    }
  });
  const definition = types.length === 0 ? buildNamedType(definitionLines, typeName) : buildType(definitionLines);
  types.push(definition); // Fix up complex type names

  types.forEach(({
    name,
    definitions
  }) => {
    const typePackage = name.split("/")[0];
    definitions.forEach(definition => {
      if (definition.isComplex) {
        const foundName = findTypeByName(types, definition.type, typePackage).name;

        if (foundName === undefined) {
          throw new Error(`Missing type definition for ${definition.type}`);
        }

        definition.type = foundName;
      }
    });
  });
  return types;
}

/***/ }),

/***/ "./src/record.js":
/*!***********************!*\
  !*** ./src/record.js ***!
  \***********************/
/*! exports provided: Record, BagHeader, Chunk, Connection, MessageData, IndexData, ChunkInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Record", function() { return Record; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BagHeader", function() { return BagHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Chunk", function() { return Chunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return Connection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageData", function() { return MessageData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IndexData", function() { return IndexData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChunkInfo", function() { return ChunkInfo; });
/* harmony import */ var int53__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! int53 */ "int53");
/* harmony import */ var int53__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(int53__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fields */ "./src/fields.js");
/* harmony import */ var _MessageReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MessageReader */ "./src/MessageReader.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Copyright (c) 2018-present, Cruise LLC
// This source code is licensed under the Apache License, Version 2.0,
// found in the LICENSE file in the root directory of this source tree.
// You may not use this file except in compliance with the License.




const readUInt64LE = buffer => {
  return int53__WEBPACK_IMPORTED_MODULE_0___default.a.readUInt64LE(buffer, 0);
};

class Record {
  constructor(_fields, _buffer) {
    _defineProperty(this, "offset", void 0);

    _defineProperty(this, "dataOffset", void 0);

    _defineProperty(this, "end", void 0);

    _defineProperty(this, "length", void 0);
  }

}
class BagHeader extends Record {
  constructor(fields, buffer) {
    super(fields, buffer);

    _defineProperty(this, "indexPosition", void 0);

    _defineProperty(this, "connectionCount", void 0);

    _defineProperty(this, "chunkCount", void 0);

    this.indexPosition = readUInt64LE(fields.index_pos);
    this.connectionCount = fields.conn_count.readInt32LE(0);
    this.chunkCount = fields.chunk_count.readInt32LE(0);
  }

}

_defineProperty(BagHeader, "opcode", 3);

class Chunk extends Record {
  constructor(fields, buffer) {
    super(fields, buffer);

    _defineProperty(this, "compression", void 0);

    _defineProperty(this, "size", void 0);

    _defineProperty(this, "data", void 0);

    this.compression = fields.compression.toString();
    this.size = fields.size.readUInt32LE(0);
    this.data = buffer;
  }

}

_defineProperty(Chunk, "opcode", 5);

const getField = (fields, key) => {
  if (fields[key] === undefined) {
    throw new Error(`Connection header is missing ${key}.`);
  }

  return fields[key].toString();
};

class Connection extends Record {
  constructor(fields, buffer) {
    super(fields, buffer);

    _defineProperty(this, "conn", void 0);

    _defineProperty(this, "topic", void 0);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "md5sum", void 0);

    _defineProperty(this, "messageDefinition", void 0);

    _defineProperty(this, "callerid", void 0);

    _defineProperty(this, "latching", void 0);

    _defineProperty(this, "reader", void 0);

    this.conn = fields.conn.readUInt32LE(0);
    this.topic = fields.topic.toString();
    this.messageDefinition = "";
    const bufferFields = Object(_fields__WEBPACK_IMPORTED_MODULE_1__["extractFields"])(buffer);
    this.type = getField(bufferFields, "type");
    this.md5sum = getField(bufferFields, "md5sum");
    this.messageDefinition = getField(bufferFields, "message_definition");

    if (bufferFields.callerid !== undefined) {
      this.callerid = bufferFields.callerid.toString();
    }

    if (bufferFields.latching !== undefined) {
      this.latching = bufferFields.latching.toString() === "1";
    }
  }

}

_defineProperty(Connection, "opcode", 7);

class MessageData extends Record {
  constructor(fields, buffer) {
    super(fields, buffer);

    _defineProperty(this, "conn", void 0);

    _defineProperty(this, "time", void 0);

    _defineProperty(this, "data", void 0);

    this.conn = fields.conn.readUInt32LE(0);
    this.time = Object(_fields__WEBPACK_IMPORTED_MODULE_1__["extractTime"])(fields.time, 0);
    this.data = buffer;
  }

}

_defineProperty(MessageData, "opcode", 2);

class IndexData extends Record {
  constructor(fields, buffer) {
    super(fields, buffer);

    _defineProperty(this, "ver", void 0);

    _defineProperty(this, "conn", void 0);

    _defineProperty(this, "count", void 0);

    _defineProperty(this, "indices", void 0);

    this.ver = fields.ver.readUInt32LE(0);
    this.conn = fields.conn.readUInt32LE(0);
    this.count = fields.count.readUInt32LE(0);
    this.indices = [];

    for (let i = 0; i < this.count; i++) {
      this.indices.push({
        time: Object(_fields__WEBPACK_IMPORTED_MODULE_1__["extractTime"])(buffer, i * 12),
        offset: buffer.readUInt32LE(i * 12 + 8)
      });
    }
  }

}

_defineProperty(IndexData, "opcode", 4);

class ChunkInfo extends Record {
  constructor(fields, buffer) {
    super(fields, buffer);

    _defineProperty(this, "ver", void 0);

    _defineProperty(this, "chunkPosition", void 0);

    _defineProperty(this, "startTime", void 0);

    _defineProperty(this, "endTime", void 0);

    _defineProperty(this, "count", void 0);

    _defineProperty(this, "connections", void 0);

    _defineProperty(this, "nextChunk", void 0);

    this.ver = fields.ver.readUInt32LE(0);
    this.chunkPosition = readUInt64LE(fields.chunk_pos);
    this.startTime = Object(_fields__WEBPACK_IMPORTED_MODULE_1__["extractTime"])(fields.start_time, 0);
    this.endTime = Object(_fields__WEBPACK_IMPORTED_MODULE_1__["extractTime"])(fields.end_time, 0);
    this.count = fields.count.readUInt32LE(0);
    this.connections = [];

    for (let i = 0; i < this.count; i++) {
      this.connections.push({
        conn: buffer.readUInt32LE(i * 8),
        count: buffer.readUInt32LE(i * 8 + 4)
      });
    }
  }

}

_defineProperty(ChunkInfo, "opcode", 6);

/***/ }),

/***/ "./src/types.js":
/*!**********************!*\
  !*** ./src/types.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "heap":
/*!***********************!*\
  !*** external "heap" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("heap");

/***/ }),

/***/ "int53":
/*!************************!*\
  !*** external "int53" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("int53");

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb3NiYWcvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3Jvc2JhZy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9yb3NiYWcvLi9zcmMvQmFnUmVhZGVyLmpzIiwid2VicGFjazovL3Jvc2JhZy8uL3NyYy9NZXNzYWdlUmVhZGVyLmpzIiwid2VicGFjazovL3Jvc2JhZy8uL3NyYy9NZXNzYWdlV3JpdGVyLmpzIiwid2VicGFjazovL3Jvc2JhZy8uL3NyYy9SZWFkUmVzdWx0LmpzIiwid2VicGFjazovL3Jvc2JhZy8uL3NyYy9UaW1lVXRpbC5qcyIsIndlYnBhY2s6Ly9yb3NiYWcvLi9zcmMvYmFnLmpzIiwid2VicGFjazovL3Jvc2JhZy8uL3NyYy9maWVsZHMuanMiLCJ3ZWJwYWNrOi8vcm9zYmFnLy4vc3JjL2hlYWRlci5qcyIsIndlYnBhY2s6Ly9yb3NiYWcvLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcm9zYmFnLy4vc3JjL25tZXJnZS5qcyIsIndlYnBhY2s6Ly9yb3NiYWcvLi9zcmMvbm9kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yb3NiYWcvLi9zcmMvcGFyc2VNZXNzYWdlRGVmaW5pdGlvbi5qcyIsIndlYnBhY2s6Ly9yb3NiYWcvLi9zcmMvcmVjb3JkLmpzIiwid2VicGFjazovL3Jvc2JhZy9leHRlcm5hbCBcImJ1ZmZlclwiIiwid2VicGFjazovL3Jvc2JhZy9leHRlcm5hbCBcImZzXCIiLCJ3ZWJwYWNrOi8vcm9zYmFnL2V4dGVybmFsIFwiaGVhcFwiIiwid2VicGFjazovL3Jvc2JhZy9leHRlcm5hbCBcImludDUzXCIiXSwibmFtZXMiOlsiSEVBREVSX1JFQURBSEVBRCIsIkhFQURFUl9PRkZTRVQiLCJCYWdSZWFkZXIiLCJjb25zdHJ1Y3RvciIsImZpbGVsaWtlIiwiX2ZpbGUiLCJfbGFzdENodW5rSW5mbyIsInVuZGVmaW5lZCIsInZlcmlmeUJhZ0hlYWRlciIsImNhbGxiYWNrIiwibmV4dCIsInJlYWQiLCJlcnJvciIsImJ1ZmZlciIsIkVycm9yIiwic2l6ZSIsInRvU3RyaW5nIiwicmVhZEhlYWRlciIsImxlbmd0aCIsImhlYWRlckxlbmd0aCIsInJlYWRJbnQzMkxFIiwiaGVhZGVyIiwicmVhZFJlY29yZEZyb21CdWZmZXIiLCJCYWdIZWFkZXIiLCJlIiwibWVzc2FnZSIsInJlYWRIZWFkZXJBc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZXJyIiwicmVhZENvbm5lY3Rpb25zQW5kQ2h1bmtJbmZvIiwiZmlsZU9mZnNldCIsImNvbm5lY3Rpb25Db3VudCIsImNodW5rQ291bnQiLCJjb25uZWN0aW9ucyIsImNodW5rSW5mb3MiLCJyZWFkUmVjb3Jkc0Zyb21CdWZmZXIiLCJDb25uZWN0aW9uIiwiY29ubmVjdGlvbkJsb2NrTGVuZ3RoIiwiZW5kIiwib2Zmc2V0Iiwic2xpY2UiLCJDaHVua0luZm8iLCJpIiwibmV4dENodW5rIiwicmVhZENvbm5lY3Rpb25zQW5kQ2h1bmtJbmZvQXN5bmMiLCJyZXN1bHQiLCJyZWFkQ2h1bmtNZXNzYWdlcyIsImNodW5rSW5mbyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJkZWNvbXByZXNzIiwic3RhcnQiLCJzZWMiLCJuc2VjIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiY29ubnMiLCJtYXAiLCJjb25uZWN0aW9uIiwiY29ubiIsInJlYWRDaHVuayIsImNodW5rIiwiaW5kaWNlcyIsImZvckVhY2giLCJpbmRleCIsInByZXNlbnRDb25uZWN0aW9ucyIsImZpbHRlciIsIml0ZXJhYmxlcyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXRlciIsIm5tZXJnZSIsImEiLCJiIiwiVGltZVV0aWwiLCJ0aW1lIiwiZW50cmllcyIsIml0ZW0iLCJkb25lIiwidmFsdWUiLCJwdXNoIiwibWVzc2FnZXMiLCJlbnRyeSIsImRhdGEiLCJkYXRhT2Zmc2V0IiwiTWVzc2FnZURhdGEiLCJyZWFkQ2h1bmtNZXNzYWdlc0FzeW5jIiwiX2xhc3RSZWFkUmVzdWx0IiwibGFzdFJlYWRSZXN1bHQiLCJzZXRJbW1lZGlhdGUiLCJyZWFkTGVuZ3RoIiwiY2h1bmtQb3NpdGlvbiIsIkNodW5rIiwiY29tcHJlc3Npb24iLCJkZWNvbXByZXNzRm4iLCJjb3VudCIsIkluZGV4RGF0YSIsImNscyIsInJlY29yZHMiLCJidWZmZXJPZmZzZXQiLCJyZWNvcmQiLCJoZWFkZXJGaWVsZHMiLCJwYXJzZUhlYWRlciIsImRhdGFMZW5ndGgiLCJTdGFuZGFyZFR5cGVSZWFkZXIiLCJ2aWV3IiwiRGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiX2ludGlhbGl6ZVRleHREZWNvZGVyIiwiZ2xvYmFsIiwiVGV4dERlY29kZXIiLCJfZGVjb2RlclN0YXR1cyIsIl9kZWNvZGVyIiwianNvbiIsInJlc3VsdFN0cmluZyIsInN0cmluZyIsIkpTT04iLCJwYXJzZSIsImxlbiIsImludDMyIiwiY29kZVBvaW50cyIsIlVpbnQ4QXJyYXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsImlucHV0IiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJkZWNvZGUiLCJib29sIiwidWludDgiLCJpbnQ4IiwiZ2V0SW50OCIsImdldFVpbnQ4IiwidHlwZWRBcnJheSIsImFycmF5VHlwZSIsImFycmF5TGVuZ3RoIiwidWludDMyIiwiaW50MTYiLCJnZXRJbnQxNiIsInVpbnQxNiIsImdldFVpbnQxNiIsImdldEludDMyIiwiZ2V0VWludDMyIiwiZmxvYXQzMiIsImdldEZsb2F0MzIiLCJmbG9hdDY0IiwiZ2V0RmxvYXQ2NCIsImludDY0IiwiaW50NTMiLCJyZWFkSW50NjRMRSIsInVpbnQ2NCIsInJlYWRVSW50NjRMRSIsImV4dHJhY3RUaW1lIiwiZHVyYXRpb24iLCJmaW5kVHlwZUJ5TmFtZSIsInR5cGVzIiwibmFtZSIsIm1hdGNoZXMiLCJ0eXBlIiwiZnJpZW5kbHlOYW1lIiwicmVwbGFjZSIsImNyZWF0ZVBhcnNlciIsInR5cGVOYW1lIiwiZnJlZXplIiwidG9wTGV2ZWxUeXBlcyIsInRvcExldmVsVHlwZSIsIm5lc3RlZFR5cGVzIiwiY29uc3RydWN0b3JCb2R5IiwicmVhZGVyTGluZXMiLCJkZWZpbml0aW9ucyIsImRlZiIsImlzQ29uc3RhbnQiLCJpc0FycmF5IiwibGVuRmllbGQiLCJhcnJheU5hbWUiLCJpc0NvbXBsZXgiLCJkZWZUeXBlIiwiam9pbiIsImpzIiwidCIsIl9yZWFkIiwiZXZhbCIsImNvbnNvbGUiLCJyZWFkZXIiLCJNZXNzYWdlUmVhZGVyIiwib3B0aW9ucyIsInBhcnNlZERlZmluaXRpb25zIiwid2FybiIsInBhcnNlTWVzc2FnZURlZmluaXRpb24iLCJyZWFkTWVzc2FnZSIsIndyaXRlVGltZSIsIndyaXRlVUludDMyTEUiLCJTdGFuZGFyZFR5cGVPZmZzZXRDYWxjdWxhdG9yIiwiX2luY3JlbWVudEFuZFJldHVybiIsImJ5dGVDb3VudCIsInN0cmluZ2lmeSIsIlN0YW5kYXJkVHlwZVdyaXRlciIsIm9mZnNldENhbGN1bGF0b3IiLCJzdHJpbmdPZmZzZXQiLCJzZXRJbnQzMiIsIndyaXRlIiwic2V0SW50OCIsInNldFVpbnQ4Iiwic2V0SW50MTYiLCJzZXRVaW50MTYiLCJzZXRVaW50MzIiLCJzZXRGbG9hdDMyIiwic2V0RmxvYXQ2NCIsIndyaXRlSW50NjRMRSIsIndyaXRlVUludDY0TEUiLCJyZXQiLCJmaW5kIiwiY3JlYXRlV3JpdGVyQW5kU2l6ZUNhbGN1bGF0b3IiLCJhcmdOYW1lIiwibGluZXMiLCJhY2Nlc3NNZXNzYWdlRmllbGQiLCJ3cml0ZXJKcyIsImNhbGN1bGF0ZVNpemVKcyIsIl93cml0ZSIsIl9jYWxjdWxhdGVTaXplIiwid3JpdGVyIiwiYnVmZmVyU2l6ZUNhbGN1bGF0b3IiLCJNZXNzYWdlV3JpdGVyIiwiY2FsY3VsYXRlQnVmZmVyU2l6ZSIsIndyaXRlTWVzc2FnZSIsImJ1ZmZlclRvV3JpdGUiLCJidWZmZXJTaXplIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJSZWFkUmVzdWx0IiwidG9waWMiLCJ0aW1lc3RhbXAiLCJjaHVua09mZnNldCIsInRvdGFsQ2h1bmtzIiwiT2JqZWN0IiwiZnJvbURhdGUiLCJkYXRlIiwiTWF0aCIsImZsb29yIiwiZ2V0VGltZSIsImdldE1pbGxpc2Vjb25kcyIsInRvRGF0ZSIsIkRhdGUiLCJjb21wYXJlIiwibGVmdCIsInJpZ2h0Iiwic2VjRGlmZiIsImlzTGVzc1RoYW4iLCJpc0dyZWF0ZXJUaGFuIiwiYXJlU2FtZSIsImFkZCIsImR1cmF0aW9uTmFub3MiLCJzZWNzRnJvbU5hbm9zIiwibmV3U2VjcyIsInJlbWFpbmluZ0R1cmF0aW9uTmFub3MiLCJuZXdOYW5vcyIsImFicyIsInNpZ24iLCJCYWciLCJiYWdSZWFkZXIiLCJvcGVuIiwiaW5kZXhQb3NpdGlvbiIsIngiLCJyZWR1Y2UiLCJwcmV2IiwiY3VycmVudCIsInJlYWRNZXNzYWdlcyIsIm9wdHMiLCJ0b3BpY3MiLCJrZXlzIiwiaWQiLCJmaWx0ZXJlZENvbm5lY3Rpb25zIiwiaW5kZXhPZiIsImluZm8iLCJwYXJzZU1zZyIsIm1zZyIsIm5vUGFyc2UiLCJtZXNzYWdlRGVmaW5pdGlvbiIsImZpbGUiLCJFUVVBTFNfQ0hBUkNPREUiLCJjaGFyQ29kZUF0IiwiZXh0cmFjdEZpZWxkcyIsImZpZWxkcyIsImZpZWxkIiwicmVhZFVJbnQzMkxFIiwib3AiLCJvcGNvZGUiLCJyZWFkVUludDgiLCJrZXkiLCJoZWFwIiwiSGVhcCIsImVtcHR5IiwiZnJvbnQiLCJwb3AiLCJSZWFkZXIiLCJmaWxlbmFtZSIsIl9maWxlbmFtZSIsIl9mZCIsIl9zaXplIiwiX2J1ZmZlciIsIl9vcGVuIiwiY2IiLCJmcyIsInN0YXQiLCJmZCIsImNsb3NlIiwiYnl0ZUxlbmd0aCIsImFsbG9jIiwiYnl0ZXMiLCJidWZmIiwiYmFnIiwicm9zUHJpbWl0aXZlVHlwZXMiLCJTZXQiLCJub3JtYWxpemVUeXBlIiwibm9ybWFsaXplZFR5cGUiLCJuZXdBcnJheURlZmluaXRpb24iLCJoYXMiLCJuZXdEZWZpbml0aW9uIiwidG9rZW5pemVMaW5lIiwibGluZSIsInNwbGl0Iiwid29yZCIsImJ1aWxkTmFtZWRUeXBlIiwiaXNKc29uIiwic3BsaXRzIiwidHJpbSIsIm1hdGNoIiwiQm9vbGVhbiIsImluY2x1ZGVzIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJ0eXBlU3BsaXRzIiwiYmFzZVR5cGUiLCJwYXJzZUludCIsImJ1aWxkVHlwZSIsInN0YXJ0c1dpdGgiLCJyb3NQYWNrYWdlIiwiZnVsbE5hbWUiLCJrIiwiYWxsTGluZXMiLCJkZWZpbml0aW9uTGluZXMiLCJuZXh0RGVmaW5pdGlvbklzSnNvbiIsImRlZmluaXRpb24iLCJ0eXBlUGFja2FnZSIsImZvdW5kTmFtZSIsIlJlY29yZCIsIl9maWVsZHMiLCJpbmRleF9wb3MiLCJjb25uX2NvdW50IiwiY2h1bmtfY291bnQiLCJnZXRGaWVsZCIsImJ1ZmZlckZpZWxkcyIsIm1kNXN1bSIsImNhbGxlcmlkIiwibGF0Y2hpbmciLCJ2ZXIiLCJjaHVua19wb3MiLCJzdGFydF90aW1lIiwiZW5kX3RpbWUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1D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QTFCO0FBQ0EsU0FBS3ZRLEtBQUwsR0FBYTJMLE1BQU0sQ0FBQzNMLEtBQVAsQ0FBYTZMLFlBQWIsQ0FBMEIsQ0FBMUIsQ0FBYjtBQUVBLFNBQUszUCxXQUFMLEdBQW1CLEVBQW5COztBQUNBLFNBQUssSUFBSVMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLcUQsS0FBekIsRUFBZ0NyRCxDQUFDLEVBQWpDLEVBQXFDO0FBQ25DLFdBQUtULFdBQUwsQ0FBaUIrQyxJQUFqQixDQUFzQjtBQUNwQnJCLFlBQUksRUFBRWhELE1BQU0sQ0FBQ2lSLFlBQVAsQ0FBb0JsUCxDQUFDLEdBQUcsQ0FBeEIsQ0FEYztBQUVwQnFELGFBQUssRUFBRXBGLE1BQU0sQ0FBQ2lSLFlBQVAsQ0FBb0JsUCxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQTVCO0FBRmEsT0FBdEI7QUFJRDtBQUNGOztBQXpCbUM7O2dCQUF6QkQsUyxZQUNLLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSWxCLG1DOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGtDIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicm9zYmFnXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInJvc2JhZ1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9ub2RlL2luZGV4LmpzXCIpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE4LXByZXNlbnQsIENydWlzZSBMTENcblxuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblxuLy8gQGZsb3dcblxuaW1wb3J0IHR5cGUgeyBUaW1lLCBDYWxsYmFjaywgRmlsZWxpa2UgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5pbXBvcnQgeyBwYXJzZUhlYWRlciB9IGZyb20gXCIuL2hlYWRlclwiO1xuaW1wb3J0IG5tZXJnZSBmcm9tIFwiLi9ubWVyZ2VcIjtcbmltcG9ydCB7IFJlY29yZCwgQmFnSGVhZGVyLCBDaHVuaywgQ2h1bmtJbmZvLCBDb25uZWN0aW9uLCBJbmRleERhdGEsIE1lc3NhZ2VEYXRhIH0gZnJvbSBcIi4vcmVjb3JkXCI7XG5pbXBvcnQgKiBhcyBUaW1lVXRpbCBmcm9tIFwiLi9UaW1lVXRpbFwiO1xuXG5pbnRlcmZhY2UgQ2h1bmtSZWFkUmVzdWx0IHtcbiAgY2h1bms6IENodW5rO1xuICBpbmRpY2VzOiBJbmRleERhdGFbXTtcbn1cblxuZXhwb3J0IHR5cGUgRGVjb21wcmVzcyA9IHtcbiAgW2NvbXByZXNzaW9uOiBzdHJpbmddOiAoYnVmZmVyOiBCdWZmZXIsIHNpemU6IG51bWJlcikgPT4gQnVmZmVyLFxufTtcblxuY29uc3QgSEVBREVSX1JFQURBSEVBRCA9IDQwOTY7XG5jb25zdCBIRUFERVJfT0ZGU0VUID0gMTM7XG5cbi8vIEJhZ1JlYWRlciBpcyBhIGxvd2VyIGxldmVsIGludGVyZmFjZSBmb3IgcmVhZGluZyBzcGVjaWZpYyBzZWN0aW9ucyAmIGNodW5rc1xuLy8gZnJvbSBhIHJvc2JhZyBmaWxlIC0gZ2VuZXJhbGx5IGl0IGlzIGNvbnN1bWVkIHRocm91Z2ggdGhlIEJhZyBjbGFzcywgYnV0XG4vLyBjYW4gYmUgdXNlZnVsIHRvIHVzZSBkaXJlY3RseSBmb3IgZWZmaWNpZW50bHkgYWNjZXNzaW5nIHJhdyBwaWVjZXMgZnJvbVxuLy8gd2l0aGluIHRoZSBiYWdcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhZ1JlYWRlciB7XG4gIF9sYXN0UmVhZFJlc3VsdDogQ2h1bmtSZWFkUmVzdWx0O1xuICBfZmlsZTogRmlsZWxpa2U7XG4gIF9sYXN0Q2h1bmtJbmZvOiA/Q2h1bmtJbmZvO1xuXG4gIGNvbnN0cnVjdG9yKGZpbGVsaWtlOiBGaWxlbGlrZSkge1xuICAgIHRoaXMuX2ZpbGUgPSBmaWxlbGlrZTtcbiAgICB0aGlzLl9sYXN0Q2h1bmtJbmZvID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmVyaWZ5QmFnSGVhZGVyKGNhbGxiYWNrOiBDYWxsYmFjazxCYWdIZWFkZXI+LCBuZXh0OiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5fZmlsZS5yZWFkKDAsIEhFQURFUl9PRkZTRVQsIChlcnJvcjogRXJyb3IgfCBudWxsLCBidWZmZXI/OiBCdWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnJvciB8fCAhYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciB8fCBuZXcgRXJyb3IoXCJNaXNzaW5nIGJvdGggZXJyb3IgYW5kIGJ1ZmZlclwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9maWxlLnNpemUoKSA8IEhFQURFUl9PRkZTRVQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIk1pc3NpbmcgZmlsZSBoZWFkZXIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlci50b1N0cmluZygpICE9PSBcIiNST1NCQUcgVjIuMFxcblwiKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5ub3QgaWRlbnRpZnkgYmFnIGZvcm1hdC5cIikpO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gcmVhZHMgdGhlIGhlYWRlciBibG9jayBmcm9tIHRoZSByb3NiYWcgZmlsZVxuICAvLyBnZW5lcmFsbHkgeW91IGNhbGwgdGhpcyBmaXJzdFxuICAvLyBiZWNhdXNlIHlvdSBuZWVkIHRoZSBoZWFkZXIgaW5mb3JtYXRpb24gdG8gY2FsbCByZWFkQ29ubmVjdGlvbnNBbmRDaHVua0luZm9cbiAgcmVhZEhlYWRlcihjYWxsYmFjazogQ2FsbGJhY2s8QmFnSGVhZGVyPikge1xuICAgIHRoaXMudmVyaWZ5QmFnSGVhZGVyKGNhbGxiYWNrLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlsZS5yZWFkKEhFQURFUl9PRkZTRVQsIEhFQURFUl9SRUFEQUhFQUQsIChlcnJvcjogRXJyb3IgfCBudWxsLCBidWZmZXI/OiBCdWZmZXIpID0+IHtcbiAgICAgICAgaWYgKGVycm9yIHx8ICFidWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IgfHwgbmV3IEVycm9yKFwiTWlzc2luZyBib3RoIGVycm9yIGFuZCBidWZmZXJcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVhZCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGlmIChyZWFkIDwgOCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYFJlY29yZCBhdCBwb3NpdGlvbiAke0hFQURFUl9PRkZTRVR9IGlzIHRydW5jYXRlZC5gKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBidWZmZXIucmVhZEludDMyTEUoMCk7XG4gICAgICAgIGlmIChyZWFkIDwgaGVhZGVyTGVuZ3RoICsgOCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYFJlY29yZCBhdCBwb3NpdGlvbiAke0hFQURFUl9PRkZTRVR9IGhlYWRlciB0b28gbGFyZ2U6ICR7aGVhZGVyTGVuZ3RofS5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLnJlYWRSZWNvcmRGcm9tQnVmZmVyKGJ1ZmZlciwgSEVBREVSX09GRlNFVCwgQmFnSGVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgaGVhZGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYENvdWxkIG5vdCByZWFkIGhlYWRlciBmcm9tIHJvc2JhZyBmaWxlIGJ1ZmZlciAtICR7ZS5tZXNzYWdlfWApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBwcm9taXNpZmllZCB2ZXJzaW9uIG9mIHJlYWRIZWFkZXJcbiAgcmVhZEhlYWRlckFzeW5jKCk6IFByb21pc2U8QmFnSGVhZGVyPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICB0aGlzLnJlYWRIZWFkZXIoKGVycjogRXJyb3IgfCBudWxsLCBoZWFkZXI/OiBCYWdIZWFkZXIpID0+IChlcnIgfHwgIWhlYWRlciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShoZWFkZXIpKSlcbiAgICApO1xuICB9XG5cbiAgLy8gcmVhZHMgY29ubmVjdGlvbiBhbmQgY2h1bmsgaW5mb3JtYXRpb24gZnJvbSB0aGUgYmFnXG4gIC8vIHlvdSdsbCBnZW5lcmFsbHkgY2FsbCB0aGlzIGFmdGVyIHJlYWRpbmcgdGhlIGhlYWRlciBzbyB5b3UgY2FuIGdldFxuICAvLyBjb25uZWN0aW9uIG1ldGFkYXRhIGFuZCBjaHVua0luZm9zIHdoaWNoIGFsbG93IHlvdSB0byBzZWVrIHRvIGluZGl2aWR1YWxcbiAgLy8gY2h1bmtzICYgcmVhZCB0aGVtXG4gIHJlYWRDb25uZWN0aW9uc0FuZENodW5rSW5mbyhcbiAgICBmaWxlT2Zmc2V0OiBudW1iZXIsXG4gICAgY29ubmVjdGlvbkNvdW50OiBudW1iZXIsXG4gICAgY2h1bmtDb3VudDogbnVtYmVyLFxuICAgIGNhbGxiYWNrOiBDYWxsYmFjazx7IGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10sIGNodW5rSW5mb3M6IENodW5rSW5mb1tdIH0+XG4gICkge1xuICAgIHRoaXMuX2ZpbGUucmVhZChmaWxlT2Zmc2V0LCB0aGlzLl9maWxlLnNpemUoKSAtIGZpbGVPZmZzZXQsIChlcnI6IEVycm9yIHwgbnVsbCwgYnVmZmVyPzogQnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyIHx8ICFidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciB8fCBuZXcgRXJyb3IoXCJNaXNzaW5nIGJvdGggZXJyb3IgYW5kIGJ1ZmZlclwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25uZWN0aW9uQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHsgY29ubmVjdGlvbnM6IFtdLCBjaHVua0luZm9zOiBbXSB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSB0aGlzLnJlYWRSZWNvcmRzRnJvbUJ1ZmZlcihidWZmZXIsIGNvbm5lY3Rpb25Db3VudCwgZmlsZU9mZnNldCwgQ29ubmVjdGlvbik7XG4gICAgICBjb25zdCBjb25uZWN0aW9uQmxvY2tMZW5ndGggPSBjb25uZWN0aW9uc1tjb25uZWN0aW9uQ291bnQgLSAxXS5lbmQgLSBjb25uZWN0aW9uc1swXS5vZmZzZXQ7XG4gICAgICBjb25zdCBjaHVua0luZm9zID0gdGhpcy5yZWFkUmVjb3Jkc0Zyb21CdWZmZXIoXG4gICAgICAgIGJ1ZmZlci5zbGljZShjb25uZWN0aW9uQmxvY2tMZW5ndGgpLFxuICAgICAgICBjaHVua0NvdW50LFxuICAgICAgICBmaWxlT2Zmc2V0ICsgY29ubmVjdGlvbkJsb2NrTGVuZ3RoLFxuICAgICAgICBDaHVua0luZm9cbiAgICAgICk7XG5cbiAgICAgIGlmIChjaHVua0NvdW50ID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rQ291bnQgLSAxOyBpKyspIHtcbiAgICAgICAgICBjaHVua0luZm9zW2ldLm5leHRDaHVuayA9IGNodW5rSW5mb3NbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rSW5mb3NbY2h1bmtDb3VudCAtIDFdLm5leHRDaHVuayA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IGNvbm5lY3Rpb25zLCBjaHVua0luZm9zIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gcHJvbWlzaWZpZWQgdmVyc2lvbiBvZiByZWFkQ29ubmVjdGlvbnNBbmRDaHVua0luZm9cbiAgcmVhZENvbm5lY3Rpb25zQW5kQ2h1bmtJbmZvQXN5bmMoXG4gICAgZmlsZU9mZnNldDogbnVtYmVyLFxuICAgIGNvbm5lY3Rpb25Db3VudDogbnVtYmVyLFxuICAgIGNodW5rQ291bnQ6IG51bWJlclxuICApOiBQcm9taXNlPHsgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXSwgY2h1bmtJbmZvczogQ2h1bmtJbmZvW10gfT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlYWRDb25uZWN0aW9uc0FuZENodW5rSW5mbyhcbiAgICAgICAgZmlsZU9mZnNldCxcbiAgICAgICAgY29ubmVjdGlvbkNvdW50LFxuICAgICAgICBjaHVua0NvdW50LFxuICAgICAgICAoZXJyOiBFcnJvciB8IG51bGwsIHJlc3VsdD86IHsgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXSwgY2h1bmtJbmZvczogQ2h1bmtJbmZvW10gfSkgPT5cbiAgICAgICAgICBlcnIgfHwgIXJlc3VsdCA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXN1bHQpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gcmVhZCBpbmRpdmlkdWFsIHJhdyBtZXNzYWdlcyBmcm9tIHRoZSBiYWcgYXQgYSBnaXZlbiBjaHVua1xuICAvLyBmaWx0ZXJzIHRvIGEgc3BlY2lmaWMgc2V0IG9mIGNvbm5lY3Rpb24gaWRzLCBzdGFydCB0aW1lLCAmIGVuZCB0aW1lXG4gIC8vIGdlbmVyYWxseSB0aGUgcmVjb3JkcyB3aWxsIGJlIG9mIHR5cGUgTWVzc2FnZURhdGFcbiAgcmVhZENodW5rTWVzc2FnZXMoXG4gICAgY2h1bmtJbmZvOiBDaHVua0luZm8sXG4gICAgY29ubmVjdGlvbnM6IG51bWJlcltdLFxuICAgIHN0YXJ0VGltZTogVGltZSB8IG51bGwsXG4gICAgZW5kVGltZTogVGltZSB8IG51bGwsXG4gICAgZGVjb21wcmVzczogRGVjb21wcmVzcyxcbiAgICBjYWxsYmFjazogQ2FsbGJhY2s8TWVzc2FnZURhdGFbXT5cbiAgKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGFydFRpbWUgfHwgeyBzZWM6IDAsIG5zZWM6IDAgfTtcbiAgICBjb25zdCBlbmQgPSBlbmRUaW1lIHx8IHsgc2VjOiBOdW1iZXIuTUFYX1ZBTFVFLCBuc2VjOiBOdW1iZXIuTUFYX1ZBTFVFIH07XG4gICAgY29uc3QgY29ubnMgPVxuICAgICAgY29ubmVjdGlvbnMgfHxcbiAgICAgIGNodW5rSW5mby5jb25uZWN0aW9ucy5tYXAoKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29ubjtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5yZWFkQ2h1bmsoY2h1bmtJbmZvLCBkZWNvbXByZXNzLCAoZXJyb3I6IEVycm9yIHwgbnVsbCwgcmVzdWx0PzogQ2h1bmtSZWFkUmVzdWx0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IgfHwgIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IgfHwgbmV3IEVycm9yKFwiTWlzc2luZyBib3RoIGVycm9yIGFuZCByZXN1bHRcIikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaHVuayA9IHJlc3VsdC5jaHVuaztcbiAgICAgIGNvbnN0IGluZGljZXM6IHsgW2Nvbm46IG51bWJlcl06IEluZGV4RGF0YSB9ID0ge307XG4gICAgICByZXN1bHQuaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICBpbmRpY2VzW2luZGV4LmNvbm5dID0gaW5kZXg7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByZXNlbnRDb25uZWN0aW9ucyA9IGNvbm5zLmZpbHRlcigoY29ubikgPT4ge1xuICAgICAgICByZXR1cm4gaW5kaWNlc1tjb25uXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBpdGVyYWJsZXMgPSBwcmVzZW50Q29ubmVjdGlvbnMubWFwKChjb25uKSA9PiB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzExNjNcbiAgICAgICAgcmV0dXJuIGluZGljZXNbY29ubl0uaW5kaWNlc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGl0ZXIgPSBubWVyZ2UoKGEsIGIpID0+IFRpbWVVdGlsLmNvbXBhcmUoYS50aW1lLCBiLnRpbWUpLCAuLi5pdGVyYWJsZXMpO1xuXG4gICAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgICBsZXQgaXRlbSA9IGl0ZXIubmV4dCgpO1xuICAgICAgd2hpbGUgKCFpdGVtLmRvbmUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gaXRlbTtcbiAgICAgICAgaXRlbSA9IGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IFRpbWVVdGlsLmlzR3JlYXRlclRoYW4oc3RhcnQsIHZhbHVlLnRpbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRpbWVVdGlsLmlzR3JlYXRlclRoYW4odmFsdWUudGltZSwgZW5kKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gZW50cmllcy5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRSZWNvcmRGcm9tQnVmZmVyKGNodW5rLmRhdGEuc2xpY2UoZW50cnkub2Zmc2V0KSwgY2h1bmsuZGF0YU9mZnNldCwgTWVzc2FnZURhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBtZXNzYWdlcyk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBwcm9taXNpZmllZCB2ZXJzaW9uIG9mIHJlYWRDaHVua01lc3NhZ2VzXG4gIHJlYWRDaHVua01lc3NhZ2VzQXN5bmMoXG4gICAgY2h1bmtJbmZvOiBDaHVua0luZm8sXG4gICAgY29ubmVjdGlvbnM6IG51bWJlcltdLFxuICAgIHN0YXJ0VGltZTogVGltZSxcbiAgICBlbmRUaW1lOiBUaW1lLFxuICAgIGRlY29tcHJlc3M6IERlY29tcHJlc3NcbiAgKTogUHJvbWlzZTxNZXNzYWdlRGF0YVtdPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVhZENodW5rTWVzc2FnZXMoXG4gICAgICAgIGNodW5rSW5mbyxcbiAgICAgICAgY29ubmVjdGlvbnMsXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZSxcbiAgICAgICAgZGVjb21wcmVzcyxcbiAgICAgICAgKGVycjogRXJyb3IgfCBudWxsLCBtZXNzYWdlcz86IE1lc3NhZ2VEYXRhW10pID0+IChlcnIgfHwgIW1lc3NhZ2VzID8gcmVqZWN0KGVycikgOiByZXNvbHZlKG1lc3NhZ2VzKSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvLyByZWFkcyBhIHNpbmdsZSBjaHVuayByZWNvcmQgJiYgaXRzIGluZGV4IHJlY29yZHMgZ2l2ZW4gYSBjaHVua0luZm9cbiAgcmVhZENodW5rKGNodW5rSW5mbzogQ2h1bmtJbmZvLCBkZWNvbXByZXNzOiBEZWNvbXByZXNzLCBjYWxsYmFjazogQ2FsbGJhY2s8Q2h1bmtSZWFkUmVzdWx0Pikge1xuICAgIC8vIGlmIHdlJ3JlIHJlYWRpbmcgdGhlIHNhbWUgY2h1bmsgYSBzZWNvbmQgdGltZSByZXR1cm4gdGhlIGNhY2hlZCB2ZXJzaW9uXG4gICAgLy8gdG8gYXZvaWQgZG9pbmcgZGVjb21wcmVzc2lvbiBvbiB0aGUgc2FtZSBjaHVuayBtdWx0aXBsZSB0aW1lcyB3aGljaCBpc1xuICAgIC8vIGV4cGVuc2l2ZVxuICAgIGlmIChjaHVua0luZm8gPT09IHRoaXMuX2xhc3RDaHVua0luZm8gJiYgdGhpcy5fbGFzdFJlYWRSZXN1bHQpIHtcbiAgICAgIC8vIGFsd2F5cyBjYWxsYmFjayBhc3luYywgZXZlbiBpZiB3ZSBoYXZlIHRoZSByZXN1bHRcbiAgICAgIC8vIGh0dHBzOi8vb3Jlbi5naXRodWIuaW8vYmxvZy96YWxnby5odG1sXG4gICAgICBjb25zdCBsYXN0UmVhZFJlc3VsdCA9IHRoaXMuX2xhc3RSZWFkUmVzdWx0O1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBsYXN0UmVhZFJlc3VsdCkpO1xuICAgIH1cbiAgICBjb25zdCB7IG5leHRDaHVuayB9ID0gY2h1bmtJbmZvO1xuXG4gICAgY29uc3QgcmVhZExlbmd0aCA9IG5leHRDaHVua1xuICAgICAgPyBuZXh0Q2h1bmsuY2h1bmtQb3NpdGlvbiAtIGNodW5rSW5mby5jaHVua1Bvc2l0aW9uXG4gICAgICA6IHRoaXMuX2ZpbGUuc2l6ZSgpIC0gY2h1bmtJbmZvLmNodW5rUG9zaXRpb247XG5cbiAgICB0aGlzLl9maWxlLnJlYWQoY2h1bmtJbmZvLmNodW5rUG9zaXRpb24sIHJlYWRMZW5ndGgsIChlcnI6IEVycm9yIHwgbnVsbCwgYnVmZmVyPzogQnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyIHx8ICFidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciB8fCBuZXcgRXJyb3IoXCJNaXNzaW5nIGJvdGggZXJyb3IgYW5kIGJ1ZmZlclwiKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5yZWFkUmVjb3JkRnJvbUJ1ZmZlcihidWZmZXIsIGNodW5rSW5mby5jaHVua1Bvc2l0aW9uLCBDaHVuayk7XG4gICAgICBjb25zdCB7IGNvbXByZXNzaW9uIH0gPSBjaHVuaztcbiAgICAgIGlmIChjb21wcmVzc2lvbiAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29uc3QgZGVjb21wcmVzc0ZuID0gZGVjb21wcmVzc1tjb21wcmVzc2lvbl07XG4gICAgICAgIGlmICghZGVjb21wcmVzc0ZuKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gdHlwZSAke2NodW5rLmNvbXByZXNzaW9ufWApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWNvbXByZXNzRm4oY2h1bmsuZGF0YSwgY2h1bmsuc2l6ZSk7XG4gICAgICAgIGNodW5rLmRhdGEgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5yZWFkUmVjb3Jkc0Zyb21CdWZmZXIoXG4gICAgICAgIGJ1ZmZlci5zbGljZShjaHVuay5sZW5ndGgpLFxuICAgICAgICBjaHVua0luZm8uY291bnQsXG4gICAgICAgIGNodW5rSW5mby5jaHVua1Bvc2l0aW9uICsgY2h1bmsubGVuZ3RoLFxuICAgICAgICBJbmRleERhdGFcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2xhc3RDaHVua0luZm8gPSBjaHVua0luZm87XG4gICAgICB0aGlzLl9sYXN0UmVhZFJlc3VsdCA9IHsgY2h1bmssIGluZGljZXMgfTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0aGlzLl9sYXN0UmVhZFJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyByZWFkcyBjb3VudCByZWNvcmRzIGZyb20gYSBidWZmZXIgc3RhcnRpbmcgYXQgZmlsZU9mZnNldFxuICByZWFkUmVjb3Jkc0Zyb21CdWZmZXI8VDogUmVjb3JkPihcbiAgICBidWZmZXI6IEJ1ZmZlcixcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIGZpbGVPZmZzZXQ6IG51bWJlcixcbiAgICBjbHM6IENsYXNzPFQ+ICYgeyBvcGNvZGU6IG51bWJlciB9XG4gICk6IFRbXSB7XG4gICAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICAgIGxldCBidWZmZXJPZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5yZWFkUmVjb3JkRnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoYnVmZmVyT2Zmc2V0KSwgZmlsZU9mZnNldCArIGJ1ZmZlck9mZnNldCwgY2xzKTtcbiAgICAgIGJ1ZmZlck9mZnNldCArPSByZWNvcmQuZW5kIC0gcmVjb3JkLm9mZnNldDtcbiAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3JkcztcbiAgfVxuXG4gIC8vIHJlYWQgYW4gaW5kaXZpZHVhbCByZWNvcmQgZnJvbSBhIGJ1ZmZlclxuICByZWFkUmVjb3JkRnJvbUJ1ZmZlcjxUOiBSZWNvcmQ+KGJ1ZmZlcjogQnVmZmVyLCBmaWxlT2Zmc2V0OiBudW1iZXIsIGNsczogQ2xhc3M8VD4gJiB7IG9wY29kZTogbnVtYmVyIH0pOiBUIHtcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSBidWZmZXIucmVhZEludDMyTEUoMCk7XG4gICAgY29uc3QgaGVhZGVyRmllbGRzID0gcGFyc2VIZWFkZXIoYnVmZmVyLnNsaWNlKDQsIDQgKyBoZWFkZXJMZW5ndGgpLCBjbHMpO1xuXG4gICAgY29uc3QgZGF0YU9mZnNldCA9IDQgKyBoZWFkZXJMZW5ndGggKyA0O1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBidWZmZXIucmVhZEludDMyTEUoNCArIGhlYWRlckxlbmd0aCk7XG4gICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5zbGljZShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YUxlbmd0aCk7XG5cbiAgICBjb25zdCByZWNvcmQgPSBuZXcgY2xzKGhlYWRlckZpZWxkcywgZGF0YSk7XG5cbiAgICByZWNvcmQub2Zmc2V0ID0gZmlsZU9mZnNldDtcbiAgICByZWNvcmQuZGF0YU9mZnNldCA9IHJlY29yZC5vZmZzZXQgKyA0ICsgaGVhZGVyTGVuZ3RoICsgNDtcbiAgICByZWNvcmQuZW5kID0gcmVjb3JkLmRhdGFPZmZzZXQgKyBkYXRhTGVuZ3RoO1xuICAgIHJlY29yZC5sZW5ndGggPSByZWNvcmQuZW5kIC0gcmVjb3JkLm9mZnNldDtcblxuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxOC1wcmVzZW50LCBDcnVpc2UgTExDXG5cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cbi8vIEBmbG93XG5cbmltcG9ydCBpbnQ1MyBmcm9tIFwiaW50NTNcIjtcbmltcG9ydCB7IGV4dHJhY3RUaW1lIH0gZnJvbSBcIi4vZmllbGRzXCI7XG5pbXBvcnQgdHlwZSB7IFJvc01zZ0RlZmluaXRpb24gfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgcGFyc2VNZXNzYWdlRGVmaW5pdGlvbiB9IGZyb20gXCIuL3BhcnNlTWVzc2FnZURlZmluaXRpb25cIjtcblxudHlwZSBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSAoXG4gIGJ1ZmZlcjogQXJyYXlCdWZmZXIsXG4gIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgbGVuZ3RoOiBudW1iZXJcbikgPT5cbiAgfCBJbnQ4QXJyYXlcbiAgfCBVaW50OEFycmF5XG4gIHwgSW50MTZBcnJheVxuICB8IFVpbnQxNkFycmF5XG4gIHwgSW50MzJBcnJheVxuICB8IFVpbnQzMkFycmF5XG4gIHwgVWludDhDbGFtcGVkQXJyYXlcbiAgfCBGbG9hdDMyQXJyYXlcbiAgfCBGbG9hdDY0QXJyYXk7XG5cbi8vIHRoaXMgaGFzIGhhcmQtY29kZWQgYnVmZmVyIHJlYWRpbmcgZnVuY3Rpb25zIGZvciBlYWNoXG4vLyBvZiB0aGUgc3RhbmRhcmQgbWVzc2FnZSB0eXBlcyBodHRwOi8vZG9jcy5yb3Mub3JnL2FwaS9zdGRfbXNncy9odG1sL2luZGV4LW1zZy5odG1sXG4vLyBldmVudHVhbGx5IGN1c3RvbSB0eXBlcyBkZWNvbXBvc2UgaW50byB0aGVzZSBzdGFuZGFyZCB0eXBlc1xuY2xhc3MgU3RhbmRhcmRUeXBlUmVhZGVyIHtcbiAgYnVmZmVyOiBCdWZmZXI7XG4gIG9mZnNldDogbnVtYmVyO1xuICB2aWV3OiBEYXRhVmlldztcbiAgX2RlY29kZXI6ID9UZXh0RGVjb2RlcjtcbiAgX2RlY29kZXJTdGF0dXM6IFwiTk9UX0lOSVRJQUxJWkVEXCIgfCBcIklOSVRJQUxJWkVEXCIgfCBcIk5PVF9BVkFJTEFCTEVcIiA9IFwiTk9UX0lOSVRJQUxJWkVEXCI7XG5cbiAgY29uc3RydWN0b3IoYnVmZmVyOiBCdWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIF9pbnRpYWxpemVUZXh0RGVjb2RlcigpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5UZXh0RGVjb2RlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5fZGVjb2RlclN0YXR1cyA9IFwiTk9UX0FWQUlMQUJMRVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IGdsb2JhbC5UZXh0RGVjb2RlcihcImFzY2lpXCIpO1xuICAgICAgdGhpcy5fZGVjb2RlclN0YXR1cyA9IFwiSU5JVElBTElaRURcIjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBTd2FsbG93IHRoZSBlcnJvciBpZiB3ZSBkb24ndCBzdXBwb3J0IGFzY2lpIGVuY29kaW5nLlxuICAgICAgdGhpcy5fZGVjb2RlclN0YXR1cyA9IFwiTk9UX0FWQUlMQUJMRVwiO1xuICAgIH1cbiAgfVxuXG4gIGpzb24oKTogbWl4ZWQge1xuICAgIGNvbnN0IHJlc3VsdFN0cmluZyA9IHRoaXMuc3RyaW5nKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdFN0cmluZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gYENvdWxkIG5vdCBwYXJzZSAke3Jlc3VsdFN0cmluZ31gO1xuICAgIH1cbiAgfVxuXG4gIHN0cmluZygpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmludDMyKCk7XG4gICAgY29uc3QgY29kZVBvaW50cyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLmJ1ZmZlciwgdGhpcy5idWZmZXIuYnl0ZU9mZnNldCArIHRoaXMub2Zmc2V0LCBsZW4pO1xuICAgIHRoaXMub2Zmc2V0ICs9IGxlbjtcblxuICAgIC8vIGlmIHRoZSBzdHJpbmcgaXMgcmVsYXRpdmVseSBzaG9ydCB3ZSBjYW4gdXNlIGFwcGx5LCBidXQgbG9uZ2VyIHN0cmluZ3MgY2FuIGJlbmVmaXQgZnJvbSB0aGUgc3BlZWQgb2YgVGV4dERlY29kZXIuXG4gICAgaWYgKGNvZGVQb2ludHMubGVuZ3RoIDwgMTAwMCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG4gICAgfVxuXG4gICAgLy8gVXNlIFRleHREZWNvZGVyIGlmIGl0IGlzIGF2YWlsYWJsZSBhbmQgc3VwcG9ydHMgdGhlIFwiYXNjaWlcIiBlbmNvZGluZy5cbiAgICBpZiAodGhpcy5fZGVjb2RlclN0YXR1cyA9PT0gXCJOT1RfSU5JVElBTElaRURcIikge1xuICAgICAgdGhpcy5faW50aWFsaXplVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlY29kZXIpIHtcbiAgICAgIC8vIFRleHREZWNvZGVyIGRvZXMgbm90IHN1cHBvcnQgVWludDhBcnJheXMgdGhhdCBhcmUgYmFja2VkIGJ5IFNoYXJlZEFycmF5QnVmZmVyLCBzbyBjb3B5IHRoZSBhcnJheSBoZXJlLlxuICAgICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgc3VwcG9ydCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgc3BlYywgYnV0IG1vc3QgYnJvd3NlcnMgaGF2ZSBub3QgaW1wbGVtZW50ZWQgdGhpcyBjaGFuZ2UuXG4gICAgICAvLyBTZWUgc3BlYyBjaGFuZ2U6IGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZW5jb2RpbmcvcHVsbC8xODJcbiAgICAgIC8vIFRyYWNrIGJyb3dzZXIgc3VwcG9ydCBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2VuY29kaW5nL3B1bGwvMTgyI2lzc3VlY29tbWVudC01Mzk5MzIyOTRcbiAgICAgIGNvbnN0IGlucHV0ID0gY29kZVBvaW50cy5idWZmZXIgaW5zdGFuY2VvZiBnbG9iYWwuU2hhcmVkQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShjb2RlUG9pbnRzKSA6IGNvZGVQb2ludHM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVyLmRlY29kZShpbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCB1c2Ugc3RyaW5nIGNvbmNhdGVudGF0aW9uLlxuICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50OCgpICE9PSAwO1xuICB9XG5cbiAgaW50OCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQrKyk7XG4gIH1cblxuICB1aW50OCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0KyspO1xuICB9XG5cbiAgdHlwZWRBcnJheShsZW46ID9udW1iZXIsIGFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgYXJyYXlMZW5ndGggPSBsZW4gPT0gbnVsbCA/IHRoaXMudWludDMyKCkgOiBsZW47XG4gICAgY29uc3QgZGF0YSA9IG5ldyBhcnJheVR5cGUodGhpcy52aWV3LmJ1ZmZlciwgdGhpcy5vZmZzZXQgKyB0aGlzLnZpZXcuYnl0ZU9mZnNldCwgYXJyYXlMZW5ndGgpO1xuICAgIHRoaXMub2Zmc2V0ICs9IGFycmF5TGVuZ3RoO1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpbnQxNigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5vZmZzZXQsIHRydWUpO1xuICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHVpbnQxNigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpbnQzMigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5vZmZzZXQsIHRydWUpO1xuICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHVpbnQzMigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmbG9hdDMyKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMub2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmbG9hdDY0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMub2Zmc2V0LCB0cnVlKTtcbiAgICB0aGlzLm9mZnNldCArPSA4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpbnQ2NCgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICB0aGlzLm9mZnNldCArPSA4O1xuICAgIHJldHVybiBpbnQ1My5yZWFkSW50NjRMRSh0aGlzLmJ1ZmZlciwgb2Zmc2V0KTtcbiAgfVxuXG4gIHVpbnQ2NCgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICB0aGlzLm9mZnNldCArPSA4O1xuICAgIHJldHVybiBpbnQ1My5yZWFkVUludDY0TEUodGhpcy5idWZmZXIsIG9mZnNldCk7XG4gIH1cblxuICB0aW1lKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIGV4dHJhY3RUaW1lKHRoaXMuYnVmZmVyLCBvZmZzZXQpO1xuICB9XG5cbiAgZHVyYXRpb24oKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgdGhpcy5vZmZzZXQgKz0gODtcbiAgICByZXR1cm4gZXh0cmFjdFRpbWUodGhpcy5idWZmZXIsIG9mZnNldCk7XG4gIH1cbn1cblxuY29uc3QgZmluZFR5cGVCeU5hbWUgPSAodHlwZXM6IFJvc01zZ0RlZmluaXRpb25bXSwgbmFtZTogc3RyaW5nKTogUm9zTXNnRGVmaW5pdGlvbiA9PiB7XG4gIGNvbnN0IG1hdGNoZXMgPSB0eXBlcy5maWx0ZXIoKHR5cGUpID0+IHR5cGUubmFtZSA9PT0gbmFtZSk7XG4gIGlmIChtYXRjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgMSB0b3AgbGV2ZWwgdHlwZSBkZWZpbml0aW9uIGZvciAnJHtuYW1lfScgYnV0IGZvdW5kICR7bWF0Y2hlcy5sZW5ndGh9LmApO1xuICB9XG4gIHJldHVybiBtYXRjaGVzWzBdO1xufTtcblxuY29uc3QgZnJpZW5kbHlOYW1lID0gKG5hbWU6IHN0cmluZykgPT4gbmFtZS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xuXG5jb25zdCBjcmVhdGVQYXJzZXIgPSAodHlwZXM6IFJvc01zZ0RlZmluaXRpb25bXSwgdHlwZU5hbWU6IHN0cmluZywgZnJlZXplOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IHRvcExldmVsVHlwZXMgPSB0eXBlcy5maWx0ZXIoKHR5cGUpID0+IHR5cGUubmFtZSA9PT0gdHlwZU5hbWUpO1xuICBpZiAodG9wTGV2ZWxUeXBlcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSB0b3AtbGV2ZWwgdHlwZXNcIik7XG4gIH1cbiAgY29uc3QgW3RvcExldmVsVHlwZV0gPSB0b3BMZXZlbFR5cGVzO1xuXG4gIGNvbnN0IG5lc3RlZFR5cGVzOiBSb3NNc2dEZWZpbml0aW9uW10gPSB0eXBlcy5maWx0ZXIoKHR5cGUpID0+IHR5cGUubmFtZSAhPT0gdHlwZU5hbWUpO1xuXG4gIGNvbnN0IGNvbnN0cnVjdG9yQm9keSA9ICh0eXBlOiBSb3NNc2dEZWZpbml0aW9uKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyTGluZXM6IHN0cmluZ1tdID0gW107XG4gICAgdHlwZS5kZWZpbml0aW9ucy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgIGlmIChkZWYuaXNDb25zdGFudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmLmlzQXJyYXkpIHtcbiAgICAgICAgaWYgKGRlZi50eXBlID09PSBcInVpbnQ4XCIgfHwgZGVmLnR5cGUgPT09IFwiaW50OFwiKSB7XG4gICAgICAgICAgY29uc3QgYXJyYXlUeXBlID0gZGVmLnR5cGUgPT09IFwidWludDhcIiA/IFwiVWludDhBcnJheVwiIDogXCJJbnQ4QXJyYXlcIjtcbiAgICAgICAgICByZWFkZXJMaW5lcy5wdXNoKGB0aGlzLiR7ZGVmLm5hbWV9ID0gcmVhZGVyLnR5cGVkQXJyYXkoJHtTdHJpbmcoZGVmLmFycmF5TGVuZ3RoKX0sICR7YXJyYXlUeXBlfSk7YCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVuRmllbGQgPSBgbGVuZ3RoXyR7ZGVmLm5hbWV9YDtcbiAgICAgICAgLy8gc2V0IGEgdmFyaWFibGUgcG9pbnRpbmcgdG8gdGhlIHBhcnNlZCBmaXhlZCBhcnJheSBsZW5ndGhcbiAgICAgICAgLy8gb3IgcmVhZCB0aGUgYnl0ZSBpbmRpY2F0aW5nIHRoZSBkeW5hbWljIGxlbmd0aFxuICAgICAgICByZWFkZXJMaW5lcy5wdXNoKGB2YXIgJHtsZW5GaWVsZH0gPSAke2RlZi5hcnJheUxlbmd0aCA/IGRlZi5hcnJheUxlbmd0aCA6IFwicmVhZGVyLnVpbnQzMigpO1wifWApO1xuXG4gICAgICAgIC8vIG9ubHkgYWxsb2NhdGUgYW4gYXJyYXkgaWYgdGhlcmUgaXMgYSBsZW5ndGggLSBza2lwcyBlbXB0eSBhbGxvY2F0aW9uc1xuICAgICAgICBjb25zdCBhcnJheU5hbWUgPSBgdGhpcy4ke2RlZi5uYW1lfWA7XG5cbiAgICAgICAgLy8gYWxsb2NhdGUgdGhlIG5ldyBhcnJheSB0byBhIGZpeGVkIGxlbmd0aCBzaW5jZSB3ZSBrbm93IGl0IGFoZWFkIG9mIHRpbWVcbiAgICAgICAgcmVhZGVyTGluZXMucHVzaChgJHthcnJheU5hbWV9ID0gbmV3IEFycmF5KCR7bGVuRmllbGR9KWApO1xuICAgICAgICAvLyBzdGFydCB0aGUgZm9yLWxvb3BcbiAgICAgICAgcmVhZGVyTGluZXMucHVzaChgZm9yICh2YXIgaSA9IDA7IGkgPCAke2xlbkZpZWxkfTsgaSsrKSB7YCk7XG4gICAgICAgIC8vIGlmIHRoZSBzdWIgdHlwZSBpcyBjb21wbGV4IHdlIG5lZWQgdG8gYWxsb2NhdGUgaXQgYW5kIHBhcnNlIGl0cyB2YWx1ZXNcbiAgICAgICAgaWYgKGRlZi5pc0NvbXBsZXgpIHtcbiAgICAgICAgICBjb25zdCBkZWZUeXBlID0gZmluZFR5cGVCeU5hbWUodHlwZXMsIGRlZi50eXBlKTtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBjYWxsIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHN1Yi10eXBlXG4gICAgICAgICAgcmVhZGVyTGluZXMucHVzaChgICAke2FycmF5TmFtZX1baV0gPSBuZXcgUmVjb3JkLiR7ZnJpZW5kbHlOYW1lKGRlZlR5cGUubmFtZSl9KHJlYWRlcik7YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHN1YnR5cGUgaXMgbm90IGNvbXBsZXggaXRzIGEgc2ltcGxlIGxvdy1sZXZlbCByZWFkZXIgb3BlcmF0aW9uXG4gICAgICAgICAgcmVhZGVyTGluZXMucHVzaChgICAke2FycmF5TmFtZX1baV0gPSByZWFkZXIuJHtkZWYudHlwZX0oKTtgKTtcbiAgICAgICAgfVxuICAgICAgICByZWFkZXJMaW5lcy5wdXNoKFwifVwiKTsgLy8gY2xvc2UgdGhlIGZvci1sb29wXG4gICAgICB9IGVsc2UgaWYgKGRlZi5pc0NvbXBsZXgpIHtcbiAgICAgICAgY29uc3QgZGVmVHlwZSA9IGZpbmRUeXBlQnlOYW1lKHR5cGVzLCBkZWYudHlwZSk7XG4gICAgICAgIHJlYWRlckxpbmVzLnB1c2goYHRoaXMuJHtkZWYubmFtZX0gPSBuZXcgUmVjb3JkLiR7ZnJpZW5kbHlOYW1lKGRlZlR5cGUubmFtZSl9KHJlYWRlcik7YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFkZXJMaW5lcy5wdXNoKGB0aGlzLiR7ZGVmLm5hbWV9ID0gcmVhZGVyLiR7ZGVmLnR5cGV9KCk7YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZyZWV6ZSkge1xuICAgICAgcmVhZGVyTGluZXMucHVzaChcIk9iamVjdC5mcmVlemUodGhpcyk7XCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVhZGVyTGluZXMuam9pbihcIlxcbiAgICBcIik7XG4gIH07XG5cbiAgbGV0IGpzID0gYFxuICB2YXIgUmVjb3JkID0gZnVuY3Rpb24gKHJlYWRlcikge1xuICAgICR7Y29uc3RydWN0b3JCb2R5KHRvcExldmVsVHlwZSl9XG4gIH07XFxuYDtcblxuICBuZXN0ZWRUeXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAganMgKz0gYFxuICBSZWNvcmQuJHtmcmllbmRseU5hbWUodC5uYW1lKX0gPSBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAke2NvbnN0cnVjdG9yQm9keSh0KX1cbiAgfTtcXG5gO1xuICB9KTtcblxuICBqcyArPSBgXG4gIHJldHVybiBmdW5jdGlvbiByZWFkKHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUmVjb3JkKHJlYWRlcik7XG4gIH07YDtcblxuICBsZXQgX3JlYWQ6IChyZWFkZXI6IFN0YW5kYXJkVHlwZVJlYWRlcikgPT4gYW55O1xuICB0cnkge1xuICAgIF9yZWFkID0gZXZhbChgKGZ1bmN0aW9uIGJ1aWxkUmVhZGVyKCkgeyAke2pzfSB9KSgpYCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgYnVpbGRpbmcgcGFyc2VyOlwiLCBqcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHRocm93IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYnVmZmVyOiBCdWZmZXIpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgU3RhbmRhcmRUeXBlUmVhZGVyKGJ1ZmZlcik7XG4gICAgcmV0dXJuIF9yZWFkKHJlYWRlcik7XG4gIH07XG59O1xuXG5leHBvcnQgY2xhc3MgTWVzc2FnZVJlYWRlciB7XG4gIHJlYWRlcjogKGJ1ZmZlcjogQnVmZmVyKSA9PiBhbnk7XG5cbiAgLy8gdGFrZXMgYW4gb2JqZWN0IG1lc3NhZ2UgZGVmaW5pdGlvbiBhbmQgcmV0dXJuc1xuICAvLyBhIG1lc3NhZ2UgcmVhZGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWQgbWVzc2FnZXMgYmFzZWRcbiAgLy8gb24gdGhlIG1lc3NhZ2UgZGVmaW5pdGlvblxuICBjb25zdHJ1Y3RvcihkZWZpbml0aW9uczogUm9zTXNnRGVmaW5pdGlvbltdLCB0eXBlTmFtZTogc3RyaW5nLCBvcHRpb25zOiB7IGZyZWV6ZT86ID9ib29sZWFuIH0gPSB7fSkge1xuICAgIGxldCBwYXJzZWREZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgIGlmICh0eXBlb2YgcGFyc2VkRGVmaW5pdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiUGFzc2luZyBzdHJpbmcgbWVzc2FnZSBkZWZpbnRpb25zIHRvIE1lc3NhZ2VSZWFkZXIgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBjYWxsIGBwYXJzZU1lc3NhZ2VEZWZpbml0aW9uYCBvbiBpdCBhbmQgcGFzcyBpbiB0aGUgcmVzdWx0aW5nIHBhcnNlZCBtZXNzYWdlIGRlZmluaXRpb24gb2JqZWN0LlwiXG4gICAgICApO1xuICAgICAgcGFyc2VkRGVmaW5pdGlvbnMgPSBwYXJzZU1lc3NhZ2VEZWZpbml0aW9uKHBhcnNlZERlZmluaXRpb25zLCB0eXBlTmFtZSk7XG4gICAgfVxuICAgIHRoaXMucmVhZGVyID0gY3JlYXRlUGFyc2VyKHBhcnNlZERlZmluaXRpb25zLCB0eXBlTmFtZSwgISFvcHRpb25zLmZyZWV6ZSk7XG4gIH1cblxuICByZWFkTWVzc2FnZShidWZmZXI6IEJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLnJlYWRlcihidWZmZXIpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTgtcHJlc2VudCwgQ3J1aXNlIExMQ1xuXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXG4vLyBAZmxvd1xuXG5pbXBvcnQgaW50NTMgZnJvbSBcImludDUzXCI7XG5pbXBvcnQgdHlwZSB7IFRpbWUsIFJvc01zZ0RlZmluaXRpb24gfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyB3cml0ZSBhIFRpbWUgb2JqZWN0IHRvIGEgYnVmZmVyLlxuZnVuY3Rpb24gd3JpdGVUaW1lKHRpbWU6IFRpbWUsIGJ1ZmZlcjogQnVmZmVyLCBvZmZzZXQ6IG51bWJlcikge1xuICBidWZmZXIud3JpdGVVSW50MzJMRSh0aW1lLnNlYywgb2Zmc2V0KTtcbiAgYnVmZmVyLndyaXRlVUludDMyTEUodGltZS5uc2VjLCBvZmZzZXQgKyA0KTtcbn1cblxuY2xhc3MgU3RhbmRhcmRUeXBlT2Zmc2V0Q2FsY3VsYXRvciB7XG4gIG9mZnNldCA9IDA7XG5cbiAgLy8gUmV0dXJucyB0aGUgY3VycmVudCBvZmZzZXQgYW5kIGluY3JlbWVudHMgdGhlIG5leHQgb2Zmc2V0IGJ5IGBieXRlQ291bnRgLlxuICBfaW5jcmVtZW50QW5kUmV0dXJuKGJ5dGVDb3VudDogbnVtYmVyKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgdGhpcy5vZmZzZXQgKz0gYnl0ZUNvdW50O1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvLyBUaGVzZSBhcmUgbm90IGFjdHVhbGx5IHVzZWQgaW4gdGhlIFN0YW5kYXJkVHlwZVdyaXRlciwgc28gdGhleSBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIHRob3NlIGltcGxlbWVudGF0aW9ucy5cbiAganNvbih2YWx1ZTogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cblxuICAvLyBUaGUgZm9sbG93aW5nIGFyZSB1c2VkIGluIHRoZSBTdGFuZGFyZFR5cGVXcml0ZXIuXG4gIHN0cmluZyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgLy8gaW50MzIgbGVuZ3RoXG4gICAgY29uc3QgbGVuZ3RoID0gNCArIHZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKGxlbmd0aCk7XG4gIH1cblxuICBib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQ4KCk7XG4gIH1cblxuICBpbnQ4KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmNyZW1lbnRBbmRSZXR1cm4oMSk7XG4gIH1cblxuICB1aW50OCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKDEpO1xuICB9XG5cbiAgaW50MTYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luY3JlbWVudEFuZFJldHVybigyKTtcbiAgfVxuXG4gIHVpbnQxNigpIHtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKDIpO1xuICB9XG5cbiAgaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luY3JlbWVudEFuZFJldHVybig0KTtcbiAgfVxuXG4gIHVpbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKDQpO1xuICB9XG5cbiAgZmxvYXQzMigpIHtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKDQpO1xuICB9XG5cbiAgZmxvYXQ2NCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKDgpO1xuICB9XG5cbiAgaW50NjQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luY3JlbWVudEFuZFJldHVybig4KTtcbiAgfVxuXG4gIHVpbnQ2NCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKDgpO1xuICB9XG5cbiAgdGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5jcmVtZW50QW5kUmV0dXJuKDgpO1xuICB9XG5cbiAgZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luY3JlbWVudEFuZFJldHVybig4KTtcbiAgfVxufVxuXG4vLyB0aGlzIGhhcyBoYXJkLWNvZGVkIGJ1ZmZlciB3cml0aW5nIGZ1bmN0aW9ucyBmb3IgZWFjaFxuLy8gb2YgdGhlIHN0YW5kYXJkIG1lc3NhZ2UgdHlwZXMgaHR0cDovL2RvY3Mucm9zLm9yZy9hcGkvc3RkX21zZ3MvaHRtbC9pbmRleC1tc2cuaHRtbFxuLy8gZXZlbnR1YWxseSBjdXN0b20gdHlwZXMgZGVjb21wb3NlIGludG8gdGhlc2Ugc3RhbmRhcmQgdHlwZXNcbmNsYXNzIFN0YW5kYXJkVHlwZVdyaXRlciB7XG4gIGJ1ZmZlcjogQnVmZmVyO1xuICB2aWV3OiBEYXRhVmlldztcbiAgb2Zmc2V0Q2FsY3VsYXRvcjogU3RhbmRhcmRUeXBlT2Zmc2V0Q2FsY3VsYXRvcjtcblxuICBjb25zdHJ1Y3RvcihidWZmZXI6IEJ1ZmZlcikge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCk7XG4gICAgdGhpcy5vZmZzZXRDYWxjdWxhdG9yID0gbmV3IFN0YW5kYXJkVHlwZU9mZnNldENhbGN1bGF0b3IoKTtcbiAgfVxuXG4gIGpzb24odmFsdWU6IGFueSkge1xuICAgIHRoaXMuc3RyaW5nKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cblxuICBzdHJpbmcodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IHN0cmluZ09mZnNldCA9IHRoaXMub2Zmc2V0Q2FsY3VsYXRvci5zdHJpbmcodmFsdWUpO1xuICAgIHRoaXMudmlldy5zZXRJbnQzMihzdHJpbmdPZmZzZXQsIHZhbHVlLmxlbmd0aCwgdHJ1ZSk7XG4gICAgdGhpcy5idWZmZXIud3JpdGUodmFsdWUsIHN0cmluZ09mZnNldCArIDQsIHZhbHVlLmxlbmd0aCwgXCJhc2NpaVwiKTtcbiAgfVxuXG4gIGJvb2wodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnVpbnQ4KHZhbHVlID8gMSA6IDApO1xuICB9XG5cbiAgaW50OCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy52aWV3LnNldEludDgodGhpcy5vZmZzZXRDYWxjdWxhdG9yLmludDgoKSwgdmFsdWUpO1xuICB9XG5cbiAgdWludDgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudmlldy5zZXRVaW50OCh0aGlzLm9mZnNldENhbGN1bGF0b3IudWludDgoKSwgdmFsdWUpO1xuICB9XG5cbiAgaW50MTYodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudmlldy5zZXRJbnQxNih0aGlzLm9mZnNldENhbGN1bGF0b3IuaW50MTYoKSwgdmFsdWUsIHRydWUpO1xuICB9XG5cbiAgdWludDE2KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLnZpZXcuc2V0VWludDE2KHRoaXMub2Zmc2V0Q2FsY3VsYXRvci51aW50MTYoKSwgdmFsdWUsIHRydWUpO1xuICB9XG5cbiAgaW50MzIodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudmlldy5zZXRJbnQzMih0aGlzLm9mZnNldENhbGN1bGF0b3IuaW50MzIoKSwgdmFsdWUsIHRydWUpO1xuICB9XG5cbiAgdWludDMyKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMub2Zmc2V0Q2FsY3VsYXRvci51aW50MzIoKSwgdmFsdWUsIHRydWUpO1xuICB9XG5cbiAgZmxvYXQzMih2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy52aWV3LnNldEZsb2F0MzIodGhpcy5vZmZzZXRDYWxjdWxhdG9yLmZsb2F0MzIoKSwgdmFsdWUsIHRydWUpO1xuICB9XG5cbiAgZmxvYXQ2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy52aWV3LnNldEZsb2F0NjQodGhpcy5vZmZzZXRDYWxjdWxhdG9yLmZsb2F0NjQoKSwgdmFsdWUsIHRydWUpO1xuICB9XG5cbiAgaW50NjQodmFsdWU6IG51bWJlcikge1xuICAgIGludDUzLndyaXRlSW50NjRMRSh2YWx1ZSwgdGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0Q2FsY3VsYXRvci5pbnQ2NCgpKTtcbiAgfVxuXG4gIHVpbnQ2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaW50NTMud3JpdGVVSW50NjRMRSh2YWx1ZSwgdGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0Q2FsY3VsYXRvci51aW50NjQoKSk7XG4gIH1cblxuICB0aW1lKHRpbWU6IFRpbWUpIHtcbiAgICB3cml0ZVRpbWUodGltZSwgdGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0Q2FsY3VsYXRvci50aW1lKCkpO1xuICB9XG5cbiAgZHVyYXRpb24odGltZTogVGltZSkge1xuICAgIHdyaXRlVGltZSh0aW1lLCB0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXRDYWxjdWxhdG9yLnRpbWUoKSk7XG4gIH1cbn1cblxuY29uc3QgZmluZFR5cGVCeU5hbWUgPSAodHlwZXM6IFJvc01zZ0RlZmluaXRpb25bXSwgbmFtZTogc3RyaW5nKTogUm9zTXNnRGVmaW5pdGlvbiA9PiB7XG4gIGNvbnN0IHJldCA9IHR5cGVzLmZpbmQoKHR5cGUpID0+IHR5cGUubmFtZSA9PT0gbmFtZSk7XG4gIGlmIChyZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSAnJHtuYW1lfScgYnV0IG5vdCBmb3VuZC5gKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuY29uc3QgZnJpZW5kbHlOYW1lID0gKG5hbWU6IHN0cmluZykgPT4gbmFtZS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpO1xudHlwZSBXcml0ZXJBbmRTaXplQ2FsY3VsYXRvciA9IHt8XG4gIHdyaXRlcjogKG1lc3NhZ2U6IGFueSwgYnVmZmVyVG9Xcml0ZTogQnVmZmVyKSA9PiBCdWZmZXIsXG4gIGJ1ZmZlclNpemVDYWxjdWxhdG9yOiAobWVzc2FnZTogYW55KSA9PiBudW1iZXIsXG58fTtcblxuZnVuY3Rpb24gY3JlYXRlV3JpdGVyQW5kU2l6ZUNhbGN1bGF0b3IodHlwZXM6IFJvc01zZ0RlZmluaXRpb25bXSwgdHlwZU5hbWU6IHN0cmluZyk6IFdyaXRlckFuZFNpemVDYWxjdWxhdG9yIHtcbiAgY29uc3QgdG9wTGV2ZWxUeXBlID0gZmluZFR5cGVCeU5hbWUodHlwZXMsIHR5cGVOYW1lKTtcbiAgY29uc3QgbmVzdGVkVHlwZXMgPSB0eXBlcy5maWx0ZXIoKHR5cGUpID0+IHR5cGUubmFtZSAhPT0gdHlwZU5hbWUpO1xuXG4gIGNvbnN0IGNvbnN0cnVjdG9yQm9keSA9ICh0eXBlOiBSb3NNc2dEZWZpbml0aW9uLCBhcmdOYW1lOiBcIm9mZnNldENhbGN1bGF0b3JcIiB8IFwid3JpdGVyXCIpID0+IHtcbiAgICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICB0eXBlLmRlZmluaXRpb25zLmZvckVhY2goKGRlZikgPT4ge1xuICAgICAgaWYgKGRlZi5pc0NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWNjZXNzZXMgdGhlIGZpZWxkIHdlIGFyZSBjdXJyZW50bHkgd3JpdGluZy4gUHVsbGVkIG91dCBmb3IgZWFzeSByZXVzZS5cbiAgICAgIGNvbnN0IGFjY2Vzc01lc3NhZ2VGaWVsZCA9IGBtZXNzYWdlW1wiJHtkZWYubmFtZX1cIl1gO1xuICAgICAgaWYgKGRlZi5pc0FycmF5KSB7XG4gICAgICAgIGNvbnN0IGxlbkZpZWxkID0gYGxlbmd0aF8ke2RlZi5uYW1lfWA7XG4gICAgICAgIC8vIHNldCBhIHZhcmlhYmxlIHBvaW50aW5nIHRvIHRoZSBwYXJzZWQgZml4ZWQgYXJyYXkgbGVuZ3RoXG4gICAgICAgIC8vIG9yIHdyaXRlIHRoZSBieXRlIGluZGljYXRpbmcgdGhlIGR5bmFtaWMgbGVuZ3RoXG4gICAgICAgIGlmIChkZWYuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKGB2YXIgJHtsZW5GaWVsZH0gPSAke2RlZi5hcnJheUxlbmd0aH07YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZXMucHVzaChgdmFyICR7bGVuRmllbGR9ID0gJHthY2Nlc3NNZXNzYWdlRmllbGR9Lmxlbmd0aDtgKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGAke2FyZ05hbWV9LnVpbnQzMigke2xlbkZpZWxkfSk7YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGFydCB0aGUgZm9yLWxvb3BcbiAgICAgICAgbGluZXMucHVzaChgZm9yICh2YXIgaSA9IDA7IGkgPCAke2xlbkZpZWxkfTsgaSsrKSB7YCk7XG4gICAgICAgIC8vIGlmIHRoZSBzdWIgdHlwZSBpcyBjb21wbGV4IHdlIG5lZWQgdG8gYWxsb2NhdGUgaXQgYW5kIHBhcnNlIGl0cyB2YWx1ZXNcbiAgICAgICAgaWYgKGRlZi5pc0NvbXBsZXgpIHtcbiAgICAgICAgICBjb25zdCBkZWZUeXBlID0gZmluZFR5cGVCeU5hbWUodHlwZXMsIGRlZi50eXBlKTtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBjYWxsIHRoZSBmdW5jdGlvbiBmb3IgdGhlIHN1Yi10eXBlXG4gICAgICAgICAgbGluZXMucHVzaChgICAke2ZyaWVuZGx5TmFtZShkZWZUeXBlLm5hbWUpfSgke2FyZ05hbWV9LCAke2FjY2Vzc01lc3NhZ2VGaWVsZH1baV0pO2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHRoZSBzdWJ0eXBlIGlzIG5vdCBjb21wbGV4IGl0cyBhIHNpbXBsZSBsb3ctbGV2ZWwgb3BlcmF0aW9uXG4gICAgICAgICAgbGluZXMucHVzaChgICAke2FyZ05hbWV9LiR7ZGVmLnR5cGV9KCR7YWNjZXNzTWVzc2FnZUZpZWxkfVtpXSk7YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMucHVzaChcIn1cIik7IC8vIGNsb3NlIHRoZSBmb3ItbG9vcFxuICAgICAgfSBlbHNlIGlmIChkZWYuaXNDb21wbGV4KSB7XG4gICAgICAgIGNvbnN0IGRlZlR5cGUgPSBmaW5kVHlwZUJ5TmFtZSh0eXBlcywgZGVmLnR5cGUpO1xuICAgICAgICBsaW5lcy5wdXNoKGAke2ZyaWVuZGx5TmFtZShkZWZUeXBlLm5hbWUpfSgke2FyZ05hbWV9LCAke2FjY2Vzc01lc3NhZ2VGaWVsZH0pO2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FsbCBwcmltaXRpdmVzIGRpcmVjdGx5LlxuICAgICAgICBsaW5lcy5wdXNoKGAke2FyZ05hbWV9LiR7ZGVmLnR5cGV9KCR7YWNjZXNzTWVzc2FnZUZpZWxkfSk7YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG4gICAgXCIpO1xuICB9O1xuXG4gIGxldCB3cml0ZXJKcyA9IFwiXCI7XG4gIGxldCBjYWxjdWxhdGVTaXplSnMgPSBcIlwiO1xuXG4gIG5lc3RlZFR5cGVzLmZvckVhY2goKHQpID0+IHtcbiAgICB3cml0ZXJKcyArPSBgXG4gIGZ1bmN0aW9uICR7ZnJpZW5kbHlOYW1lKHQubmFtZSl9KHdyaXRlciwgbWVzc2FnZSkge1xuICAgICR7Y29uc3RydWN0b3JCb2R5KHQsIFwid3JpdGVyXCIpfVxuICB9O1xcbmA7XG4gICAgY2FsY3VsYXRlU2l6ZUpzICs9IGBcbiAgZnVuY3Rpb24gJHtmcmllbmRseU5hbWUodC5uYW1lKX0ob2Zmc2V0Q2FsY3VsYXRvciwgbWVzc2FnZSkge1xuICAgICR7Y29uc3RydWN0b3JCb2R5KHQsIFwib2Zmc2V0Q2FsY3VsYXRvclwiKX1cbiAgfTtcXG5gO1xuICB9KTtcblxuICB3cml0ZXJKcyArPSBgXG4gIHJldHVybiBmdW5jdGlvbiB3cml0ZSh3cml0ZXIsIG1lc3NhZ2UpIHtcbiAgICAke2NvbnN0cnVjdG9yQm9keSh0b3BMZXZlbFR5cGUsIFwid3JpdGVyXCIpfVxuICAgIHJldHVybiB3cml0ZXIuYnVmZmVyO1xuICB9O2A7XG4gIGNhbGN1bGF0ZVNpemVKcyArPSBgXG4gIHJldHVybiBmdW5jdGlvbiBjYWxjdWxhdGVTaXplKG9mZnNldENhbGN1bGF0b3IsIG1lc3NhZ2UpIHtcbiAgICAke2NvbnN0cnVjdG9yQm9keSh0b3BMZXZlbFR5cGUsIFwib2Zmc2V0Q2FsY3VsYXRvclwiKX1cbiAgICByZXR1cm4gb2Zmc2V0Q2FsY3VsYXRvci5vZmZzZXQ7XG4gIH07YDtcblxuICBsZXQgX3dyaXRlOiAod3JpdGVyOiBTdGFuZGFyZFR5cGVXcml0ZXIsIG1lc3NhZ2U6IGFueSkgPT4gQnVmZmVyO1xuICBsZXQgX2NhbGN1bGF0ZVNpemU6IChvZmZzZXRDYWxjdWxhdG9yOiBTdGFuZGFyZFR5cGVPZmZzZXRDYWxjdWxhdG9yLCBtZXNzYWdlOiBhbnkpID0+IG51bWJlcjtcbiAgdHJ5IHtcbiAgICBfd3JpdGUgPSBldmFsKGAoZnVuY3Rpb24gYnVpbGRXcml0ZXIoKSB7ICR7d3JpdGVySnN9IH0pKClgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBidWlsZGluZyB3cml0ZXI6XCIsIHdyaXRlckpzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgdGhyb3cgZTtcbiAgfVxuICB0cnkge1xuICAgIF9jYWxjdWxhdGVTaXplID0gZXZhbChgKGZ1bmN0aW9uIGJ1aWxkU2l6ZUNhbGN1bGF0b3IoKSB7ICR7Y2FsY3VsYXRlU2l6ZUpzfSB9KSgpYCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgYnVpbGRpbmcgc2l6ZSBjYWxjdWxhdG9yOlwiLCBjYWxjdWxhdGVTaXplSnMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB0aHJvdyBlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3cml0ZXI6IGZ1bmN0aW9uKG1lc3NhZ2U6IGFueSwgYnVmZmVyOiBCdWZmZXIpOiBCdWZmZXIge1xuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFN0YW5kYXJkVHlwZVdyaXRlcihidWZmZXIpO1xuICAgICAgcmV0dXJuIF93cml0ZSh3cml0ZXIsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgYnVmZmVyU2l6ZUNhbGN1bGF0b3IobWVzc2FnZTogYW55KTogbnVtYmVyIHtcbiAgICAgIGNvbnN0IG9mZnNldENhbGN1bGF0b3IgPSBuZXcgU3RhbmRhcmRUeXBlT2Zmc2V0Q2FsY3VsYXRvcigpO1xuICAgICAgcmV0dXJuIF9jYWxjdWxhdGVTaXplKG9mZnNldENhbGN1bGF0b3IsIG1lc3NhZ2UpO1xuICAgIH0sXG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlV3JpdGVyIHtcbiAgd3JpdGVyOiAobWVzc2FnZTogYW55LCBidWZmZXJUb1dyaXRlOiBCdWZmZXIpID0+IEJ1ZmZlcjtcbiAgYnVmZmVyU2l6ZUNhbGN1bGF0b3I6IChtZXNzYWdlOiBhbnkpID0+IG51bWJlcjtcblxuICAvLyB0YWtlcyBhbiBvYmplY3Qgc3RyaW5nIG1lc3NhZ2UgZGVmaW5pdGlvbiBhbmQgcmV0dXJuc1xuICAvLyBhIG1lc3NhZ2Ugd3JpdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHdyaXRlIG1lc3NhZ2VzIGJhc2VkXG4gIC8vIG9uIHRoZSBtZXNzYWdlIGRlZmluaXRpb25cbiAgY29uc3RydWN0b3IoZGVmaW5pdGlvbnM6IFJvc01zZ0RlZmluaXRpb25bXSwgdHlwZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHsgd3JpdGVyLCBidWZmZXJTaXplQ2FsY3VsYXRvciB9ID0gY3JlYXRlV3JpdGVyQW5kU2l6ZUNhbGN1bGF0b3IoZGVmaW5pdGlvbnMsIHR5cGVOYW1lKTtcbiAgICB0aGlzLndyaXRlciA9IHdyaXRlcjtcbiAgICB0aGlzLmJ1ZmZlclNpemVDYWxjdWxhdG9yID0gYnVmZmVyU2l6ZUNhbGN1bGF0b3I7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHRoZSBidWZmZXIgc2l6ZSBuZWVkZWQgdG8gd3JpdGUgdGhpcyBtZXNzYWdlIGluIGJ5dGVzLlxuICBjYWxjdWxhdGVCdWZmZXJTaXplKG1lc3NhZ2U6IGFueSkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlclNpemVDYWxjdWxhdG9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgLy8gYnVmZmVyVG9Xcml0ZSBpcyBvcHRpb25hbCAtIGlmIGl0IGlzIG5vdCBwcm92aWRlZCwgYSBidWZmZXIgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gIHdyaXRlTWVzc2FnZShtZXNzYWdlOiBhbnksIGJ1ZmZlclRvV3JpdGU/OiBCdWZmZXIpIHtcbiAgICBsZXQgYnVmZmVyID0gYnVmZmVyVG9Xcml0ZTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IHRoaXMuY2FsY3VsYXRlQnVmZmVyU2l6ZShtZXNzYWdlKTtcbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZmZXJTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud3JpdGVyKG1lc3NhZ2UsIGJ1ZmZlcik7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxOC1wcmVzZW50LCBDcnVpc2UgTExDXG5cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cbi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIHsgVGltZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbi8vIHJlcHJlc2VudHMgYSByZXN1bHQgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBoaWdoLWxldmVsIGNhbGw6XG4vLyBiYWcucmVhZE1lc3NhZ2VzKHsgb3B0czogYW55IH0sIGNhbGxiYWNrOiAoUmVhZFJlc3VsdCkgPT4gdm9pZCkgPT4gUHJvbWlzZTx2b2lkPlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhZFJlc3VsdDxUPiB7XG4gIHRvcGljOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IFQ7XG4gIHRpbWVzdGFtcDogVGltZTtcbiAgZGF0YTogQnVmZmVyO1xuICBjaHVua09mZnNldDogbnVtYmVyO1xuICB0b3RhbENodW5rczogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHRvcGljOiBzdHJpbmcsXG4gICAgbWVzc2FnZTogVCxcbiAgICB0aW1lc3RhbXA6IFRpbWUsXG4gICAgZGF0YTogQnVmZmVyLFxuICAgIGNodW5rT2Zmc2V0OiBudW1iZXIsXG4gICAgdG90YWxDaHVua3M6IG51bWJlcixcbiAgICBmcmVlemU/OiA/Ym9vbGVhblxuICApIHtcbiAgICAvLyBzdHJpbmc6IHRoZSB0b3BpYyB0aGUgbWVzc2FnZSB3YXMgb25cbiAgICB0aGlzLnRvcGljID0gdG9waWM7XG5cbiAgICAvLyBhbnk6IHRoZSBwYXJzZWQgYm9keSBvZiB0aGUgbWVzc2FnZSBiYXNlZCBvbiBjb25uZWN0aW9uLm1lc3NhZ2VEZWZpbml0aW9uXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAgIC8vIHRpbWU6IHRoZSB0aW1lc3RhbXAgb2YgdGhlIG1lc3NhZ2VcbiAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblxuICAgIC8vIGJ1ZmZlcjogcmF3IGJ1ZmZlciBkYXRhIG9mIHRoZSBtZXNzYWdlXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8vIHRoZSBvZmZzZXQgb2YgdGhlIGN1cnJlbnRseSByZWFkIGNodW5rXG4gICAgdGhpcy5jaHVua09mZnNldCA9IGNodW5rT2Zmc2V0O1xuXG4gICAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiBjaHVua3MgaW4gdGhlIHJlYWQgb3BlcmF0aW9uXG4gICAgdGhpcy50b3RhbENodW5rcyA9IHRvdGFsQ2h1bmtzO1xuXG4gICAgaWYgKGZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aW1lc3RhbXApO1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxOC1wcmVzZW50LCBDcnVpc2UgTExDXG5cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cbi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIHsgVGltZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRGF0ZShkYXRlOiBEYXRlKSB7XG4gIGNvbnN0IHNlYyA9IE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgY29uc3QgbnNlYyA9IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxZTY7XG4gIHJldHVybiB7IHNlYywgbnNlYyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRlKHRpbWU6IFRpbWUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWUuc2VjICogMWUzICsgdGltZS5uc2VjIC8gMWU2KTtcbn1cblxuLy8gY29tcGFyZSB0d28gdGltZXMsIHJldHVybmluZyBhIG5lZ2F0aXZlIHZhbHVlIGlmIHRoZSByaWdodCBpcyBncmVhdGVyXG4vLyBvciBhIHBvc2l0aXZlIHZhbHVlIGlmIHRoZSBsZWZ0IGlzIGdyZWF0ZXIgb3IgMCBpZiB0aGUgdGltZXMgYXJlIGVxdWFsXG4vLyB1c2VmdWwgdG8gc3VwcGx5IHRvIEFycmF5LnByb3RvdHlwZS5zb3J0XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShsZWZ0OiBUaW1lLCByaWdodDogVGltZSkge1xuICBjb25zdCBzZWNEaWZmID0gbGVmdC5zZWMgLSByaWdodC5zZWM7XG4gIHJldHVybiBzZWNEaWZmIHx8IGxlZnQubnNlYyAtIHJpZ2h0Lm5zZWM7XG59XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGVmdCB0aW1lIGlzIGxlc3MgdGhhbiB0aGUgcmlnaHQgdGltZSwgb3RoZXJ3aXNlIGZhbHNlXG5leHBvcnQgZnVuY3Rpb24gaXNMZXNzVGhhbihsZWZ0OiBUaW1lLCByaWdodDogVGltZSkge1xuICByZXR1cm4gdGhpcy5jb21wYXJlKGxlZnQsIHJpZ2h0KSA8IDA7XG59XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGVmdCB0aW1lIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmlnaHQgdGltZSwgb3RoZXJ3aXNlIGZhbHNlXG5leHBvcnQgZnVuY3Rpb24gaXNHcmVhdGVyVGhhbihsZWZ0OiBUaW1lLCByaWdodDogVGltZSkge1xuICByZXR1cm4gdGhpcy5jb21wYXJlKGxlZnQsIHJpZ2h0KSA+IDA7XG59XG5cbi8vIHJldHVybnMgdHJ1ZSBpZiBib3RoIHRpbWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNlY29uZHMgYW5kIG5hbm9zZWNvbmRzXG5leHBvcnQgZnVuY3Rpb24gYXJlU2FtZShsZWZ0OiBUaW1lLCByaWdodDogVGltZSkge1xuICByZXR1cm4gbGVmdC5zZWMgPT09IHJpZ2h0LnNlYyAmJiBsZWZ0Lm5zZWMgPT09IHJpZ2h0Lm5zZWM7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHRpbWU6IFRpbWUpIHtcbiAgcmV0dXJuIGB7JHt0aW1lLnNlY30sICR7dGltZS5uc2VjfX1gO1xufVxuXG4vLyBjb21wdXRlcyB0aGUgc3VtIG9mIHR3byB0aW1lcyBvciBkdXJhdGlvbnMgYW5kIHJldHVybnMgYSBuZXcgdGltZVxuLy8gdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgcmVzdWx0aW5nIHRpbWUgaXMgbmVnYXRpdmVcbmV4cG9ydCBmdW5jdGlvbiBhZGQobGVmdDogVGltZSwgcmlnaHQ6IFRpbWUpIHtcbiAgY29uc3QgZHVyYXRpb25OYW5vcyA9IGxlZnQubnNlYyArIHJpZ2h0Lm5zZWM7XG4gIGNvbnN0IHNlY3NGcm9tTmFub3MgPSBNYXRoLmZsb29yKGR1cmF0aW9uTmFub3MgLyAxZTkpO1xuICBjb25zdCBuZXdTZWNzID0gbGVmdC5zZWMgKyByaWdodC5zZWMgKyBzZWNzRnJvbU5hbm9zO1xuICBjb25zdCByZW1haW5pbmdEdXJhdGlvbk5hbm9zID0gZHVyYXRpb25OYW5vcyAlIDFlOTtcbiAgLy8gdXNlIE1hdGguYWJzIGhlcmUgdG8gcHJldmVudCAtMCB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgMSBzZWNvbmQgb2YgbmVnYXRpdmUgbmFub3NlY29uZHMgcGFzc2VkIGluXG4gIGNvbnN0IG5ld05hbm9zID0gTWF0aC5hYnMoXG4gICAgTWF0aC5zaWduKHJlbWFpbmluZ0R1cmF0aW9uTmFub3MpID09PSAtMSA/IDFlOSArIHJlbWFpbmluZ0R1cmF0aW9uTmFub3MgOiByZW1haW5pbmdEdXJhdGlvbk5hbm9zXG4gICk7XG4gIGNvbnN0IHJlc3VsdCA9IHsgc2VjOiBuZXdTZWNzLCBuc2VjOiBuZXdOYW5vcyB9O1xuICBpZiAocmVzdWx0LnNlYyA8IDAgfHwgcmVzdWx0Lm5zZWMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdGltZTogJHt0b1N0cmluZyhyZXN1bHQpfSBwcm9kdWNlZCBmcm9tIFRpbWVVdGlsLmFkZCgke3RvU3RyaW5nKGxlZnQpfSwgJHt0b1N0cmluZyhyaWdodCl9fSlgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE4LXByZXNlbnQsIENydWlzZSBMTENcblxuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblxuLy8gQGZsb3dcblxuaW1wb3J0IEJhZ1JlYWRlciwgeyB0eXBlIERlY29tcHJlc3MgfSBmcm9tIFwiLi9CYWdSZWFkZXJcIjtcbmltcG9ydCB7IE1lc3NhZ2VSZWFkZXIgfSBmcm9tIFwiLi9NZXNzYWdlUmVhZGVyXCI7XG5pbXBvcnQgUmVhZFJlc3VsdCBmcm9tIFwiLi9SZWFkUmVzdWx0XCI7XG5pbXBvcnQgeyBCYWdIZWFkZXIsIENodW5rSW5mbywgQ29ubmVjdGlvbiwgTWVzc2FnZURhdGEgfSBmcm9tIFwiLi9yZWNvcmRcIjtcbmltcG9ydCB0eXBlIHsgVGltZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgKiBhcyBUaW1lVXRpbCBmcm9tIFwiLi9UaW1lVXRpbFwiO1xuaW1wb3J0IHsgcGFyc2VNZXNzYWdlRGVmaW5pdGlvbiB9IGZyb20gXCIuL3BhcnNlTWVzc2FnZURlZmluaXRpb25cIjtcblxuZXhwb3J0IHR5cGUgUmVhZE9wdGlvbnMgPSB7fFxuICBkZWNvbXByZXNzPzogRGVjb21wcmVzcyxcbiAgbm9QYXJzZT86IGJvb2xlYW4sXG4gIHRvcGljcz86IHN0cmluZ1tdLFxuICBzdGFydFRpbWU/OiBUaW1lLFxuICBlbmRUaW1lPzogVGltZSxcbiAgZnJlZXplPzogP2Jvb2xlYW4sXG58fTtcblxuLy8gdGhlIGhpZ2ggbGV2ZWwgcm9zYmFnIGludGVyZmFjZVxuLy8gY3JlYXRlIGEgbmV3IGJhZyBieSBjYWxsaW5nOlxuLy8gYGNvbnN0IGJhZyA9IGF3YWl0IEJhZy5vcGVuKCcuL3BhdGgtdG8tZmlsZS5iYWcnKWAgaW4gbm9kZSBvclxuLy8gYGNvbnN0IGJhZyA9IGF3YWl0IEJhZy5vcGVuKGZpbGVzWzBdKWAgaW4gdGhlIGJyb3dzZXJcbi8vXG4vLyBhZnRlciB0aGF0IHlvdSBjYW4gY29uc3VtZSBtZXNzYWdlcyBieSBjYWxsaW5nXG4vLyBgYXdhaXQgYmFnLnJlYWRNZXNzYWdlcyh7IHRvcGljczogWycvZm9vJ10gfSxcbi8vICAgIChyZXN1bHQpID0+IGNvbnNvbGUubG9nKHJlc3VsdC50b3BpYywgcmVzdWx0Lm1lc3NhZ2UpKWBcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhZyB7XG4gIHJlYWRlcjogQmFnUmVhZGVyO1xuICBoZWFkZXI6IEJhZ0hlYWRlcjtcbiAgY29ubmVjdGlvbnM6IHsgW2Nvbm46IG51bWJlcl06IENvbm5lY3Rpb24gfTtcbiAgY2h1bmtJbmZvczogQ2h1bmtJbmZvW107XG4gIHN0YXJ0VGltZTogP1RpbWU7XG4gIGVuZFRpbWU6ID9UaW1lO1xuXG4gIC8vIHlvdSBjYW4gb3B0aW9uYWxseSBjcmVhdGUgYSBiYWcgbWFudWFsbHkgcGFzc2luZyBpbiBhIGJhZ1JlYWRlciBpbnN0YW5jZVxuICBjb25zdHJ1Y3RvcihiYWdSZWFkZXI6IEJhZ1JlYWRlcikge1xuICAgIHRoaXMucmVhZGVyID0gYmFnUmVhZGVyO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHN0YXRpYyBvcGVuID0gKGZpbGU6IEZpbGUgfCBzdHJpbmcpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoaXMgbWV0aG9kIHNob3VsZCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQuIE1ha2Ugc3VyZSB5b3UgYXJlIGNvcnJlY3RseSBpbXBvcnRpbmcgdGhlIG5vZGUgb3Igd2ViIHZlcnNpb24gb2YgQmFnLlwiXG4gICAgKTtcbiAgfTtcblxuICAvLyBpZiB0aGUgYmFnIGlzIG1hbnVhbGx5IGNyZWF0ZWQgd2l0aCB0aGUgY29uc3RydWN0b3IsIHlvdSBtdXN0IGNhbGwgYGF3YWl0IG9wZW4oKWAgb24gdGhlIGJhZ1xuICAvLyBnZW5lcmFsbHkgdGhpcyBpcyBjYWxsZWQgZm9yIHlvdSBpZiB5b3UncmUgdXNpbmcgYGNvbnN0IGJhZyA9IGF3YWl0IEJhZy5vcGVuKClgXG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgdGhpcy5oZWFkZXIgPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkSGVhZGVyQXN5bmMoKTtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25Db3VudCwgY2h1bmtDb3VudCwgaW5kZXhQb3NpdGlvbiB9ID0gdGhpcy5oZWFkZXI7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkQ29ubmVjdGlvbnNBbmRDaHVua0luZm9Bc3luYyhpbmRleFBvc2l0aW9uLCBjb25uZWN0aW9uQ291bnQsIGNodW5rQ291bnQpO1xuXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IHt9O1xuXG4gICAgcmVzdWx0LmNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbi5jb25uXSA9IGNvbm5lY3Rpb247XG4gICAgfSk7XG5cbiAgICB0aGlzLmNodW5rSW5mb3MgPSByZXN1bHQuY2h1bmtJbmZvcztcblxuICAgIGlmIChjaHVua0NvdW50ID4gMCkge1xuICAgICAgLy8gR2V0IHRoZSBlYXJsaWVzdCBzdGFydFRpbWUgYW1vbmcgYWxsIGNodW5rc1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNodW5rSW5mb3NcbiAgICAgICAgLm1hcCgoeCkgPT4geC5zdGFydFRpbWUpXG4gICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IChUaW1lVXRpbC5jb21wYXJlKHByZXYsIGN1cnJlbnQpIDw9IDAgPyBwcmV2IDogY3VycmVudCkpO1xuICAgICAgLy8gR2V0IHRoZSBsYXRlc3QgZW5kVGltZSBhbW9uZyBhbGwgY2h1bmtzXG4gICAgICB0aGlzLmVuZFRpbWUgPSB0aGlzLmNodW5rSW5mb3NcbiAgICAgICAgLm1hcCgoeCkgPT4geC5lbmRUaW1lKVxuICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiAoVGltZVV0aWwuY29tcGFyZShwcmV2LCBjdXJyZW50KSA+IDAgPyBwcmV2IDogY3VycmVudCkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlYWRNZXNzYWdlcyhvcHRzOiBSZWFkT3B0aW9ucywgY2FsbGJhY2s6IChtc2c6IFJlYWRSZXN1bHQ8YW55PikgPT4gdm9pZCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9ucztcblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG9wdHMuc3RhcnRUaW1lIHx8IHsgc2VjOiAwLCBuc2VjOiAwIH07XG4gICAgY29uc3QgZW5kVGltZSA9IG9wdHMuZW5kVGltZSB8fCB7IHNlYzogTnVtYmVyLk1BWF9WQUxVRSwgbnNlYzogTnVtYmVyLk1BWF9WQUxVRSB9O1xuICAgIGNvbnN0IHRvcGljcyA9XG4gICAgICBvcHRzLnRvcGljcyB8fFxuICAgICAgT2JqZWN0LmtleXMoY29ubmVjdGlvbnMpLm1hcCgoaWQ6IGFueSkgPT4ge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbnNbaWRdLnRvcGljO1xuICAgICAgfSk7XG5cbiAgICBjb25zdCBmaWx0ZXJlZENvbm5lY3Rpb25zID0gT2JqZWN0LmtleXMoY29ubmVjdGlvbnMpXG4gICAgICAuZmlsdGVyKChpZDogYW55KSA9PiB7XG4gICAgICAgIHJldHVybiB0b3BpY3MuaW5kZXhPZihjb25uZWN0aW9uc1tpZF0udG9waWMpICE9PSAtMTtcbiAgICAgIH0pXG4gICAgICAubWFwKChpZCkgPT4gK2lkKTtcblxuICAgIGNvbnN0IHsgZGVjb21wcmVzcyA9IHt9IH0gPSBvcHRzO1xuXG4gICAgLy8gZmlsdGVyIGNodW5rcyB0byB0aG9zZSB3aGljaCBmYWxsIHdpdGhpbiB0aGUgdGltZSByYW5nZSB3ZSdyZSBhdHRlbXB0aW5nIHRvIHJlYWRcbiAgICBjb25zdCBjaHVua0luZm9zID0gdGhpcy5jaHVua0luZm9zLmZpbHRlcigoaW5mbykgPT4ge1xuICAgICAgcmV0dXJuIFRpbWVVdGlsLmNvbXBhcmUoaW5mby5zdGFydFRpbWUsIGVuZFRpbWUpIDw9IDAgJiYgVGltZVV0aWwuY29tcGFyZShzdGFydFRpbWUsIGluZm8uZW5kVGltZSkgPD0gMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlTXNnKG1zZzogTWVzc2FnZURhdGEsIGNodW5rT2Zmc2V0OiBudW1iZXIpOiBSZWFkUmVzdWx0PGFueT4ge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zW21zZy5jb25uXTtcbiAgICAgIGNvbnN0IHsgdG9waWMsIHR5cGUgfSA9IGNvbm5lY3Rpb247XG4gICAgICBjb25zdCB7IGRhdGEsIHRpbWU6IHRpbWVzdGFtcCB9ID0gbXNnO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBudWxsO1xuICAgICAgaWYgKCFvcHRzLm5vUGFyc2UpIHtcbiAgICAgICAgLy8gbGF6aWx5IGNyZWF0ZSBhIHJlYWRlciBmb3IgdGhpcyBjb25uZWN0aW9uIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgY29ubmVjdGlvbi5yZWFkZXIgPVxuICAgICAgICAgIGNvbm5lY3Rpb24ucmVhZGVyIHx8XG4gICAgICAgICAgbmV3IE1lc3NhZ2VSZWFkZXIocGFyc2VNZXNzYWdlRGVmaW5pdGlvbihjb25uZWN0aW9uLm1lc3NhZ2VEZWZpbml0aW9uLCB0eXBlKSwgdHlwZSwgeyBmcmVlemU6IG9wdHMuZnJlZXplIH0pO1xuICAgICAgICBtZXNzYWdlID0gY29ubmVjdGlvbi5yZWFkZXIucmVhZE1lc3NhZ2UoZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlYWRSZXN1bHQodG9waWMsIG1lc3NhZ2UsIHRpbWVzdGFtcCwgZGF0YSwgY2h1bmtPZmZzZXQsIGNodW5rSW5mb3MubGVuZ3RoLCBvcHRzLmZyZWV6ZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua0luZm9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmZvID0gY2h1bmtJbmZvc1tpXTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZENodW5rTWVzc2FnZXNBc3luYyhcbiAgICAgICAgaW5mbyxcbiAgICAgICAgZmlsdGVyZWRDb25uZWN0aW9ucyxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBlbmRUaW1lLFxuICAgICAgICBkZWNvbXByZXNzXG4gICAgICApO1xuICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobXNnKSA9PiBjYWxsYmFjayhwYXJzZU1zZyhtc2csIGkpKSk7XG4gICAgfVxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTgtcHJlc2VudCwgQ3J1aXNlIExMQ1xuXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXG4vLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7IFRpbWUgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyByZWFkcyB0aHJvdWdoIGEgYnVmZmVyIGFuZCBleHRyYWN0cyB7IFtrZXk6IHN0cmluZ106IHZhbHVlOiBzdHJpbmcgfVxuLy8gcGFpcnMgLSB0aGUgYnVmZmVyIGlzIGV4cGVjdGVkIHRvIGhhdmUgbGVuZ3RoIHByZWZpeGVkIHV0Zjggc3RyaW5nc1xuLy8gd2l0aCBhICc9JyBzZXBhcmF0aW5nIHRoZSBrZXkgYW5kIHZhbHVlXG5jb25zdCBFUVVBTFNfQ0hBUkNPREUgPSBcIj1cIi5jaGFyQ29kZUF0KDApO1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RGaWVsZHMoYnVmZmVyOiBCdWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVyIGZpZWxkcyBhcmUgdHJ1bmNhdGVkLlwiKTtcbiAgfVxuXG4gIGxldCBpID0gMDtcbiAgY29uc3QgZmllbGRzOiB7IFtrZXk6IHN0cmluZ106IEJ1ZmZlciB9ID0ge307XG5cbiAgd2hpbGUgKGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLnJlYWRJbnQzMkxFKGkpO1xuICAgIGkgKz0gNDtcblxuICAgIGlmIChpICsgbGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVyIGZpZWxkcyBhcmUgY29ycnVwdC5cIik7XG4gICAgfVxuXG4gICAgLy8gUGFzc2luZyBhIG51bWJlciBpbnRvIFwiaW5kZXhPZlwiIGV4cGxpY2l0bHkgdG8gYXZvaWQgQnVmZmVyIHBvbHlmaWxsXG4gICAgLy8gc2xvdyBwYXRoLiBTZWUgaXNzdWUgIzg3LlxuICAgIGNvbnN0IGZpZWxkID0gYnVmZmVyLnNsaWNlKGksIGkgKyBsZW5ndGgpO1xuICAgIGNvbnN0IGluZGV4ID0gZmllbGQuaW5kZXhPZihFUVVBTFNfQ0hBUkNPREUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlciBmaWVsZCBpcyBtaXNzaW5nIGVxdWFscyBzaWduLlwiKTtcbiAgICB9XG5cbiAgICBmaWVsZHNbZmllbGQuc2xpY2UoMCwgaW5kZXgpLnRvU3RyaW5nKCldID0gZmllbGQuc2xpY2UoaW5kZXggKyAxKTtcbiAgICBpICs9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8vIHJlYWRzIGEgVGltZSBvYmplY3Qgb3V0IG9mIGEgYnVmZmVyIGF0IHRoZSBnaXZlbiBvZmZzZXRcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGltZShidWZmZXI6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIpOiBUaW1lIHtcbiAgY29uc3Qgc2VjID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICBjb25zdCBuc2VjID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIHsgc2VjLCBuc2VjIH07XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTgtcHJlc2VudCwgQ3J1aXNlIExMQ1xuXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXG4vLyBAZmxvd1xuXG5pbXBvcnQgeyBleHRyYWN0RmllbGRzIH0gZnJvbSBcIi4vZmllbGRzXCI7XG5pbXBvcnQgeyBSZWNvcmQgfSBmcm9tIFwiLi9yZWNvcmRcIjtcblxuLy8gZ2l2ZW4gYSBidWZmZXIgcGFyc2VzIG91dCB0aGUgcmVjb3JkIHdpdGhpbiB0aGUgYnVmZmVyXG4vLyBiYXNlZCBvbiB0aGUgb3Bjb2RlIHR5cGUgYml0XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIZWFkZXI8VDogUmVjb3JkPihidWZmZXI6IEJ1ZmZlciwgY2xzOiBDbGFzczxUPiAmIHsgb3Bjb2RlOiBudW1iZXIgfSk6IHsgW2tleTogc3RyaW5nXTogQnVmZmVyIH0ge1xuICBjb25zdCBmaWVsZHMgPSBleHRyYWN0RmllbGRzKGJ1ZmZlcik7XG4gIGlmIChmaWVsZHMub3AgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlciBpcyBtaXNzaW5nICdvcCcgZmllbGQuXCIpO1xuICB9XG4gIGNvbnN0IG9wY29kZSA9IGZpZWxkcy5vcC5yZWFkVUludDgoMCk7XG4gIGlmIChvcGNvZGUgIT09IGNscy5vcGNvZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7Y2xzLm5hbWV9ICgke2Nscy5vcGNvZGV9KSBidXQgZm91bmQgJHtvcGNvZGV9YCk7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE4LXByZXNlbnQsIENydWlzZSBMTENcblxuLy8gVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wLFxuLy8gZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbi8vIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblxuLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgVGltZVV0aWwgZnJvbSBcIi4vVGltZVV0aWxcIjtcblxuZXhwb3J0ICogZnJvbSBcIi4vYmFnXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CYWdSZWFkZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL01lc3NhZ2VSZWFkZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL01lc3NhZ2VXcml0ZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BhcnNlTWVzc2FnZURlZmluaXRpb25cIjtcbmV4cG9ydCAqIGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9maWVsZHNcIjtcbmV4cG9ydCB7IFRpbWVVdGlsIH07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTgtcHJlc2VudCwgQ3J1aXNlIExMQ1xuXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXG4vLyBAZmxvd1xuXG5pbXBvcnQgSGVhcCBmcm9tIFwiaGVhcFwiO1xuXG5mdW5jdGlvbiBubWVyZ2U8VD4oa2V5OiAoYTogVCwgYjogVCkgPT4gbnVtYmVyLCAuLi5pdGVyYWJsZXM6IEFycmF5PEl0ZXJhdG9yPFQ+Pikge1xuICBjb25zdCBoZWFwOiBIZWFwPHsgaTogbnVtYmVyLCB2YWx1ZTogVCB9PiA9IG5ldyBIZWFwKChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGtleShhLnZhbHVlLCBiLnZhbHVlKTtcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaXRlcmFibGVzW2ldLm5leHQoKTtcbiAgICBpZiAoIWRvbmUpIHtcbiAgICAgIGhlYXAucHVzaCh7IGksIHZhbHVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgaWYgKGhlYXAuZW1wdHkoKSkge1xuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgICBjb25zdCB7IGkgfSA9IGhlYXAuZnJvbnQoKTtcbiAgICAgIGNvbnN0IG5leHQgPSBpdGVyYWJsZXNbaV0ubmV4dCgpO1xuICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogaGVhcC5wb3AoKS52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHZhbHVlOiBoZWFwLnJlcGxhY2UoeyBpLCB2YWx1ZTogbmV4dC52YWx1ZSB9KS52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBubWVyZ2U7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTgtcHJlc2VudCwgQ3J1aXNlIExMQ1xuXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXG4vLyBAZmxvd1xuXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7XG4gIE1lc3NhZ2VSZWFkZXIsXG4gIE1lc3NhZ2VXcml0ZXIsXG4gIHBhcnNlTWVzc2FnZURlZmluaXRpb24sXG4gIHJvc1ByaW1pdGl2ZVR5cGVzLFxuICBUaW1lVXRpbCxcbiAgZXh0cmFjdEZpZWxkcyxcbiAgZXh0cmFjdFRpbWUsXG59IGZyb20gXCIuLi9pbmRleFwiO1xuaW1wb3J0IHR5cGUgeyBDYWxsYmFjayB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IEJhZyBmcm9tIFwiLi4vYmFnXCI7XG5pbXBvcnQgQmFnUmVhZGVyIGZyb20gXCIuLi9CYWdSZWFkZXJcIjtcblxuLy8gcmVhZGVyIHVzaW5nIG5vZGVqcyBmcyBhcGlcbmV4cG9ydCBjbGFzcyBSZWFkZXIge1xuICBfZmlsZW5hbWU6IHN0cmluZztcbiAgX2ZkOiA/bnVtYmVyO1xuICBfc2l6ZTogbnVtYmVyO1xuICBfYnVmZmVyOiBCdWZmZXI7XG5cbiAgY29uc3RydWN0b3IoZmlsZW5hbWU6IHN0cmluZykge1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgdGhpcy5fZmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5fYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICB9XG5cbiAgLy8gb3BlbiBhIGZpbGUgZm9yIHJlYWRpbmdcbiAgX29wZW4oY2I6IChlcnJvcjogP0Vycm9yKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgZnMuc3RhdCh0aGlzLl9maWxlbmFtZSwgKGVycm9yLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZzLm9wZW4odGhpcy5fZmlsZW5hbWUsIFwiclwiLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mZCA9IGZkO1xuICAgICAgICB0aGlzLl9zaXplID0gc3RhdC5zaXplO1xuICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlKGNiOiAoZXJyb3I6ID9FcnJvcikgPT4gdm9pZCkge1xuICAgIGlmICh0aGlzLl9mZCAhPSBudWxsKSB7XG4gICAgICBmcy5jbG9zZSh0aGlzLl9mZCwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlYWQgbGVuZ3RoIChieXRlcykgc3RhcnRpbmcgZnJvbSBvZmZzZXQgKGJ5dGVzKVxuICAvLyBjYWxsYmFjayhlcnIsIGJ1ZmZlcilcbiAgcmVhZChvZmZzZXQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIGNiOiBDYWxsYmFjazxCdWZmZXI+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2ZkID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcGVuKChlcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IGNiKGVycikgOiB0aGlzLnJlYWQob2Zmc2V0LCBsZW5ndGgsIGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID4gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRoaXMuX2J1ZmZlciA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gZnMucmVhZCh0aGlzLl9mZCwgdGhpcy5fYnVmZmVyLCAwLCBsZW5ndGgsIG9mZnNldCwgKGVyciwgYnl0ZXMsIGJ1ZmYpID0+IHtcbiAgICAgIHJldHVybiBlcnIgPyBjYihlcnIpIDogY2IobnVsbCwgYnVmZik7XG4gICAgfSk7XG4gIH1cblxuICAvLyByZXR1cm4gdGhlIHNpemUgb2YgdGhlIGZpbGVcbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxufVxuXG5jb25zdCBvcGVuID0gYXN5bmMgKGZpbGVuYW1lOiBGaWxlIHwgc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZmlsZW5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGZpbGVuYW1lIHRvIGJlIGEgc3RyaW5nLiBNYWtlIHN1cmUgeW91IGFyZSBjb3JyZWN0bHkgaW1wb3J0aW5nIHRoZSBub2RlIG9yIHdlYiB2ZXJzaW9uIG9mIEJhZy5cIlxuICAgICk7XG4gIH1cbiAgY29uc3QgYmFnID0gbmV3IEJhZyhuZXcgQmFnUmVhZGVyKG5ldyBSZWFkZXIoZmlsZW5hbWUpKSk7XG4gIGF3YWl0IGJhZy5vcGVuKCk7XG4gIHJldHVybiBiYWc7XG59O1xuQmFnLm9wZW4gPSBvcGVuO1xuXG5leHBvcnQgKiBmcm9tIFwiLi4vdHlwZXNcIjtcbmV4cG9ydCB7XG4gIFRpbWVVdGlsLFxuICBCYWdSZWFkZXIsXG4gIE1lc3NhZ2VSZWFkZXIsXG4gIE1lc3NhZ2VXcml0ZXIsXG4gIG9wZW4sXG4gIHBhcnNlTWVzc2FnZURlZmluaXRpb24sXG4gIHJvc1ByaW1pdGl2ZVR5cGVzLFxuICBleHRyYWN0RmllbGRzLFxuICBleHRyYWN0VGltZSxcbn07XG5leHBvcnQgZGVmYXVsdCBCYWc7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTgtcHJlc2VudCwgQ3J1aXNlIExMQ1xuXG4vLyBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAsXG4vLyBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuLy8gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuXG4vLyBAZmxvd1xuXG5pbXBvcnQgdHlwZSB7IFJvc01zZ0ZpZWxkLCBSb3NNc2dEZWZpbml0aW9uIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gU2V0IG9mIGJ1aWx0LWluIHJvcyB0eXBlcy4gU2VlIGh0dHA6Ly93aWtpLnJvcy5vcmcvbXNnI0ZpZWxkX1R5cGVzXG5leHBvcnQgY29uc3Qgcm9zUHJpbWl0aXZlVHlwZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChbXG4gIFwic3RyaW5nXCIsXG4gIFwiYm9vbFwiLFxuICBcImludDhcIixcbiAgXCJ1aW50OFwiLFxuICBcImludDE2XCIsXG4gIFwidWludDE2XCIsXG4gIFwiaW50MzJcIixcbiAgXCJ1aW50MzJcIixcbiAgXCJmbG9hdDMyXCIsXG4gIFwiZmxvYXQ2NFwiLFxuICBcImludDY0XCIsXG4gIFwidWludDY0XCIsXG4gIFwidGltZVwiLFxuICBcImR1cmF0aW9uXCIsXG4gIFwianNvblwiLFxuXSk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVR5cGUodHlwZTogc3RyaW5nKSB7XG4gIC8vIE5vcm1hbGl6ZSBkZXByZWNhdGVkIGFsaWFzZXMuXG4gIGxldCBub3JtYWxpemVkVHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlID09PSBcImNoYXJcIikge1xuICAgIG5vcm1hbGl6ZWRUeXBlID0gXCJ1aW50OFwiO1xuICB9XG4gIGlmICh0eXBlID09PSBcImJ5dGVcIikge1xuICAgIG5vcm1hbGl6ZWRUeXBlID0gXCJpbnQ4XCI7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRUeXBlO1xufVxuXG4vLyByZXByZXNlbnRzIGEgc2luZ2xlIGxpbmUgaW4gYSBtZXNzYWdlIGRlZmluaXRpb24gdHlwZVxuLy8gZS5nLiAnc3RyaW5nIG5hbWUnICdDdXN0b21UeXBlW10gZm9vJyAnc3RyaW5nWzNdIG5hbWVzJ1xuZnVuY3Rpb24gbmV3QXJyYXlEZWZpbml0aW9uKHR5cGU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBhcnJheUxlbmd0aDogP251bWJlcik6IFJvc01zZ0ZpZWxkIHtcbiAgY29uc3Qgbm9ybWFsaXplZFR5cGUgPSBub3JtYWxpemVUeXBlKHR5cGUpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IG5vcm1hbGl6ZWRUeXBlLFxuICAgIG5hbWUsXG4gICAgaXNBcnJheTogdHJ1ZSxcbiAgICBhcnJheUxlbmd0aDogYXJyYXlMZW5ndGggPT09IG51bGwgPyB1bmRlZmluZWQgOiBhcnJheUxlbmd0aCxcbiAgICBpc0NvbXBsZXg6ICFyb3NQcmltaXRpdmVUeXBlcy5oYXMobm9ybWFsaXplZFR5cGUpLFxuICB9O1xufVxuZnVuY3Rpb24gbmV3RGVmaW5pdGlvbih0eXBlOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IFJvc01zZ0ZpZWxkIHtcbiAgY29uc3Qgbm9ybWFsaXplZFR5cGUgPSBub3JtYWxpemVUeXBlKHR5cGUpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IG5vcm1hbGl6ZWRUeXBlLFxuICAgIG5hbWUsXG4gICAgaXNBcnJheTogZmFsc2UsXG4gICAgaXNDb21wbGV4OiAhcm9zUHJpbWl0aXZlVHlwZXMuaGFzKG5vcm1hbGl6ZWRUeXBlKSxcbiAgfTtcbn1cblxuY29uc3QgdG9rZW5pemVMaW5lID0gKGxpbmU6IHN0cmluZykgPT5cbiAgbGluZVxuICAgIC5yZXBsYWNlKC8jLiovZ2ksIFwiXCIpXG4gICAgLnNwbGl0KFwiIFwiKVxuICAgIC5maWx0ZXIoKHdvcmQpID0+IHdvcmQpO1xuXG5jb25zdCBidWlsZE5hbWVkVHlwZSA9IChsaW5lczogeyBpc0pzb246IGJvb2xlYW4sIGxpbmU6IHN0cmluZyB9W10sIHR5cGVOYW1lOiBzdHJpbmcpOiBSb3NNc2dEZWZpbml0aW9uID0+IHtcbiAgY29uc3QgZGVmaW5pdGlvbnM6IFJvc01zZ0ZpZWxkW10gPSBbXTtcbiAgbGluZXMuZm9yRWFjaCgoeyBpc0pzb24sIGxpbmUgfSkgPT4ge1xuICAgIC8vIHJlbW92ZSBjb21tZW50cyBhbmQgZXh0cmEgd2hpdGVzcGFjZSBmcm9tIGVhY2ggbGluZVxuICAgIGNvbnN0IHNwbGl0cyA9IHRva2VuaXplTGluZShsaW5lKTtcbiAgICBpZiAoIXNwbGl0c1sxXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjb25zdW1lIGNvbW1lbnRzXG4gICAgY29uc3QgdHlwZSA9IHNwbGl0c1swXS50cmltKCk7XG4gICAgY29uc3QgbmFtZSA9IHNwbGl0c1sxXS50cmltKCk7XG4gICAgaWYgKG5hbWUuaW5kZXhPZihcIj1cIikgPiAtMSB8fCBzcGxpdHMuaW5kZXhPZihcIj1cIikgPiAtMSkge1xuICAgICAgLy8gY29uc3RhbnQgdHlwZSBwYXJzaW5nXG4gICAgICBjb25zdCBtYXRjaGVzID0gbGluZS5tYXRjaCgvKFxcUyspXFxzKj1cXHMqKC4qKVxccyovKTtcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgbGluZTogXCIgKyBsaW5lKTtcbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZTogYW55ID0gbWF0Y2hlc1syXTtcbiAgICAgIGlmICh0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgcHl0aG9uIGJvb2wgdmFsdWVzXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvVHJ1ZS9naSwgXCJ0cnVlXCIpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL0ZhbHNlL2dpLCBcImZhbHNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZS5yZXBsYWNlKC9cXHMqIy4qL2csIFwiXCIpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgaW4gdGhpcyBjb25zdGFudCBkZWZpbml0aW9uOiAke2xpbmV9YCk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYm9vbFwiKSB7XG4gICAgICAgICAgdmFsdWUgPSBCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCh0eXBlLmluY2x1ZGVzKFwiaW50XCIpICYmIHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHx8IHZhbHVlIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKGBGb3VuZCBpbnRlZ2VyIGNvbnN0YW50IG91dHNpZGUgc2FmZSBpbnRlZ2VyIHJhbmdlOiAke2xpbmV9YCk7XG4gICAgICB9XG4gICAgICBkZWZpbml0aW9ucy5wdXNoKHtcbiAgICAgICAgdHlwZTogbm9ybWFsaXplVHlwZSh0eXBlKSxcbiAgICAgICAgbmFtZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgaXNDb25zdGFudDogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuaW5kZXhPZihcIl1cIikgPT09IHR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gYXJyYXkgdHlwZSBwYXJzaW5nXG4gICAgICBjb25zdCB0eXBlU3BsaXRzID0gdHlwZS5zcGxpdChcIltcIik7XG4gICAgICBjb25zdCBiYXNlVHlwZSA9IHR5cGVTcGxpdHNbMF07XG4gICAgICBjb25zdCBsZW4gPSB0eXBlU3BsaXRzWzFdLnJlcGxhY2UoXCJdXCIsIFwiXCIpO1xuICAgICAgZGVmaW5pdGlvbnMucHVzaChuZXdBcnJheURlZmluaXRpb24oYmFzZVR5cGUsIG5hbWUsIGxlbiA/IHBhcnNlSW50KGxlbiwgMTApIDogdW5kZWZpbmVkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluaXRpb25zLnB1c2gobmV3RGVmaW5pdGlvbihpc0pzb24gPyBcImpzb25cIiA6IHR5cGUsIG5hbWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBuYW1lOiB0eXBlTmFtZSwgZGVmaW5pdGlvbnMgfTtcbn07XG5cbmNvbnN0IGJ1aWxkVHlwZSA9IChsaW5lczogeyBpc0pzb246IGJvb2xlYW4sIGxpbmU6IHN0cmluZyB9W10pOiBSb3NNc2dEZWZpbml0aW9uID0+IHtcbiAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IG1lc3NhZ2UgZGVmaW5pdGlvbi5cIik7XG4gIH1cbiAgaWYgKCFsaW5lc1swXS5saW5lLnN0YXJ0c1dpdGgoXCJNU0c6IFwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIG1lc3NhZ2UgZGVmaW5pdGlvbiBuYW1lOiAke2xpbmVzWzBdLmxpbmV9YCk7XG4gIH1cbiAgY29uc3QgdHlwZU5hbWUgPSB0b2tlbml6ZUxpbmUobGluZXNbMF0ubGluZSlbMV0udHJpbSgpO1xuICByZXR1cm4gYnVpbGROYW1lZFR5cGUobGluZXMuc2xpY2UoMSksIHR5cGVOYW1lKTtcbn07XG5cbmNvbnN0IGZpbmRUeXBlQnlOYW1lID0gKHR5cGVzOiBSb3NNc2dEZWZpbml0aW9uW10sIG5hbWU6IHN0cmluZywgcm9zUGFja2FnZTogc3RyaW5nKTogUm9zTXNnRGVmaW5pdGlvbiA9PiB7XG4gIGNvbnN0IGZ1bGxOYW1lID0gbmFtZS5pbmNsdWRlcyhcIi9cIikgPyBuYW1lIDogbmFtZSA9PT0gXCJIZWFkZXJcIiA/IFwic3RkX21zZ3MvSGVhZGVyXCIgOiBgJHtyb3NQYWNrYWdlfS8ke25hbWV9YDtcbiAgY29uc3QgbWF0Y2hlcyA9IHR5cGVzLmZpbHRlcigodHlwZSkgPT4gdHlwZS5uYW1lID09PSBmdWxsTmFtZSk7XG4gIGlmIChtYXRjaGVzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCAxIHRvcCBsZXZlbCB0eXBlIGRlZmluaXRpb24gZm9yICcke25hbWV9JyBidXQgZm91bmQgJHttYXRjaGVzLmxlbmd0aH0sICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBmdWxsTmFtZSxcbiAgICAgICAgazogdHlwZXMubWFwKCh0eXBlKSA9PiB0eXBlLm5hbWUpLFxuICAgICAgfSl9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXNbMF07XG59O1xuXG4vLyBHaXZlbiBhIHJhdyBtZXNzYWdlIGRlZmluaXRpb24gc3RyaW5nLCBwYXJzZSBpdCBpbnRvIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbi5cbi8vIFR5cGUgbmFtZXMgaW4gYWxsIHBvc2l0aW9ucyBhcmUgYWx3YXlzIGZ1bGx5LXF1YWxpZmllZC5cbi8vXG4vLyBFeGFtcGxlIHJldHVybiB2YWx1ZTpcbi8vIFt7XG4vLyAgIG5hbWU6IFwiZm9vX21zZ3MvQmFyXCIsXG4vLyAgIGRlZmluaXRpb25zOiBbXG4vLyAgICAge1xuLy8gICAgICAgYXJyYXlMZW5ndGg6IHVuZGVmaW5lZCxcbi8vICAgICAgIGlzQXJyYXk6IGZhbHNlLFxuLy8gICAgICAgaXNDb21wbGV4OiBmYWxzZSxcbi8vICAgICAgIG5hbWU6IFwibmFtZVwiLFxuLy8gICAgICAgdHlwZTogXCJzdHJpbmdcIixcbi8vICAgICB9LCAuLi5cbi8vICAgXSxcbi8vIH0sIC4uLiBdXG4vL1xuLy8gU2VlIHVuaXQgdGVzdHMgZm9yIG1vcmUgZXhhbXBsZXMuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNZXNzYWdlRGVmaW5pdGlvbihtZXNzYWdlRGVmaW5pdGlvbjogc3RyaW5nLCB0eXBlTmFtZTogc3RyaW5nKSB7XG4gIC8vIHJlYWQgYWxsIHRoZSBsaW5lcyBhbmQgcmVtb3ZlIGVtcHRpZXNcbiAgY29uc3QgYWxsTGluZXMgPSBtZXNzYWdlRGVmaW5pdGlvblxuICAgIC5zcGxpdChcIlxcblwiKVxuICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgIC5maWx0ZXIoKGxpbmUpID0+IGxpbmUpO1xuXG4gIGxldCBkZWZpbml0aW9uTGluZXM6IHsgaXNKc29uOiBib29sZWFuLCBsaW5lOiBzdHJpbmcgfVtdID0gW107XG4gIGNvbnN0IHR5cGVzOiBSb3NNc2dEZWZpbml0aW9uW10gPSBbXTtcbiAgbGV0IG5leHREZWZpbml0aW9uSXNKc29uOiBib29sZWFuID0gZmFsc2U7XG4gIC8vIGdyb3VwIGxpbmVzIGludG8gaW5kaXZpZHVhbCBkZWZpbml0aW9uc1xuICBhbGxMaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgLy8gaWdub3JlIGNvbW1lbnQgbGluZXMgdW5sZXNzIHRoZXkgc3RhcnQgd2l0aCAjcHJhZ21hIHJvc2JhZ19wYXJzZV9qc29uXG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCIjcHJhZ21hIHJvc2JhZ19wYXJzZV9qc29uXCIpKSB7XG4gICAgICAgIG5leHREZWZpbml0aW9uSXNKc29uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBkZWZpbml0aW9ucyBhcmUgc3BsaXQgYnkgZXF1YWwgc2lnbnNcbiAgICBpZiAobGluZS5zdGFydHNXaXRoKFwiPT1cIikpIHtcbiAgICAgIG5leHREZWZpbml0aW9uSXNKc29uID0gZmFsc2U7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gdHlwZXMubGVuZ3RoID09PSAwID8gYnVpbGROYW1lZFR5cGUoZGVmaW5pdGlvbkxpbmVzLCB0eXBlTmFtZSkgOiBidWlsZFR5cGUoZGVmaW5pdGlvbkxpbmVzKTtcbiAgICAgIHR5cGVzLnB1c2goZGVmaW5pdGlvbik7XG4gICAgICBkZWZpbml0aW9uTGluZXMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5pdGlvbkxpbmVzLnB1c2goeyBpc0pzb246IG5leHREZWZpbml0aW9uSXNKc29uLCBsaW5lIH0pO1xuICAgICAgbmV4dERlZmluaXRpb25Jc0pzb24gPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBkZWZpbml0aW9uID0gdHlwZXMubGVuZ3RoID09PSAwID8gYnVpbGROYW1lZFR5cGUoZGVmaW5pdGlvbkxpbmVzLCB0eXBlTmFtZSkgOiBidWlsZFR5cGUoZGVmaW5pdGlvbkxpbmVzKTtcbiAgdHlwZXMucHVzaChkZWZpbml0aW9uKTtcblxuICAvLyBGaXggdXAgY29tcGxleCB0eXBlIG5hbWVzXG4gIHR5cGVzLmZvckVhY2goKHsgbmFtZSwgZGVmaW5pdGlvbnMgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGVQYWNrYWdlID0gbmFtZS5zcGxpdChcIi9cIilbMF07XG4gICAgZGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgaWYgKGRlZmluaXRpb24uaXNDb21wbGV4KSB7XG4gICAgICAgIGNvbnN0IGZvdW5kTmFtZSA9IGZpbmRUeXBlQnlOYW1lKHR5cGVzLCBkZWZpbml0aW9uLnR5cGUsIHR5cGVQYWNrYWdlKS5uYW1lO1xuICAgICAgICBpZiAoZm91bmROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgdHlwZSBkZWZpbml0aW9uIGZvciAke2RlZmluaXRpb24udHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbml0aW9uLnR5cGUgPSBmb3VuZE5hbWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0eXBlcztcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxOC1wcmVzZW50LCBDcnVpc2UgTExDXG5cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCxcbi8vIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4vLyBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5cbi8vIEBmbG93XG5cbmltcG9ydCBpbnQ1MyBmcm9tIFwiaW50NTNcIjtcblxuaW1wb3J0IHsgZXh0cmFjdEZpZWxkcywgZXh0cmFjdFRpbWUgfSBmcm9tIFwiLi9maWVsZHNcIjtcbmltcG9ydCB7IE1lc3NhZ2VSZWFkZXIgfSBmcm9tIFwiLi9NZXNzYWdlUmVhZGVyXCI7XG5pbXBvcnQgdHlwZSB7IFRpbWUgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5jb25zdCByZWFkVUludDY0TEUgPSAoYnVmZmVyOiBCdWZmZXIpID0+IHtcbiAgcmV0dXJuIGludDUzLnJlYWRVSW50NjRMRShidWZmZXIsIDApO1xufTtcblxuZXhwb3J0IGNsYXNzIFJlY29yZCB7XG4gIG9mZnNldDogbnVtYmVyO1xuICBkYXRhT2Zmc2V0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICBsZW5ndGg6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihfZmllbGRzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LCBfYnVmZmVyOiBCdWZmZXIpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBCYWdIZWFkZXIgZXh0ZW5kcyBSZWNvcmQge1xuICBzdGF0aWMgb3Bjb2RlID0gMztcbiAgaW5kZXhQb3NpdGlvbjogbnVtYmVyO1xuICBjb25uZWN0aW9uQ291bnQ6IG51bWJlcjtcbiAgY2h1bmtDb3VudDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogeyBba2V5OiBzdHJpbmddOiBCdWZmZXIgfSwgYnVmZmVyOiBCdWZmZXIpIHtcbiAgICBzdXBlcihmaWVsZHMsIGJ1ZmZlcik7XG4gICAgdGhpcy5pbmRleFBvc2l0aW9uID0gcmVhZFVJbnQ2NExFKGZpZWxkcy5pbmRleF9wb3MpO1xuICAgIHRoaXMuY29ubmVjdGlvbkNvdW50ID0gZmllbGRzLmNvbm5fY291bnQucmVhZEludDMyTEUoMCk7XG4gICAgdGhpcy5jaHVua0NvdW50ID0gZmllbGRzLmNodW5rX2NvdW50LnJlYWRJbnQzMkxFKDApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDaHVuayBleHRlbmRzIFJlY29yZCB7XG4gIHN0YXRpYyBvcGNvZGUgPSA1O1xuICBjb21wcmVzc2lvbjogc3RyaW5nO1xuICBzaXplOiBudW1iZXI7XG4gIGRhdGE6IEJ1ZmZlcjtcblxuICBjb25zdHJ1Y3RvcihmaWVsZHM6IHsgW2tleTogc3RyaW5nXTogQnVmZmVyIH0sIGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgc3VwZXIoZmllbGRzLCBidWZmZXIpO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBmaWVsZHMuY29tcHJlc3Npb24udG9TdHJpbmcoKTtcbiAgICB0aGlzLnNpemUgPSBmaWVsZHMuc2l6ZS5yZWFkVUludDMyTEUoMCk7XG4gICAgdGhpcy5kYXRhID0gYnVmZmVyO1xuICB9XG59XG5cbmNvbnN0IGdldEZpZWxkID0gKGZpZWxkczogeyBba2V5OiBzdHJpbmddOiBCdWZmZXIgfSwga2V5OiBzdHJpbmcpID0+IHtcbiAgaWYgKGZpZWxkc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbm5lY3Rpb24gaGVhZGVyIGlzIG1pc3NpbmcgJHtrZXl9LmApO1xuICB9XG4gIHJldHVybiBmaWVsZHNba2V5XS50b1N0cmluZygpO1xufTtcblxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb24gZXh0ZW5kcyBSZWNvcmQge1xuICBzdGF0aWMgb3Bjb2RlID0gNztcbiAgY29ubjogbnVtYmVyO1xuICB0b3BpYzogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIG1kNXN1bTogc3RyaW5nO1xuICBtZXNzYWdlRGVmaW5pdGlvbjogc3RyaW5nO1xuICBjYWxsZXJpZDogP3N0cmluZztcbiAgbGF0Y2hpbmc6ID9ib29sZWFuO1xuICByZWFkZXI6ID9NZXNzYWdlUmVhZGVyO1xuXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogeyBba2V5OiBzdHJpbmddOiBCdWZmZXIgfSwgYnVmZmVyOiBCdWZmZXIpIHtcbiAgICBzdXBlcihmaWVsZHMsIGJ1ZmZlcik7XG4gICAgdGhpcy5jb25uID0gZmllbGRzLmNvbm4ucmVhZFVJbnQzMkxFKDApO1xuICAgIHRoaXMudG9waWMgPSBmaWVsZHMudG9waWMudG9TdHJpbmcoKTtcbiAgICB0aGlzLm1lc3NhZ2VEZWZpbml0aW9uID0gXCJcIjtcblxuICAgIGNvbnN0IGJ1ZmZlckZpZWxkcyA9IGV4dHJhY3RGaWVsZHMoYnVmZmVyKTtcbiAgICB0aGlzLnR5cGUgPSBnZXRGaWVsZChidWZmZXJGaWVsZHMsIFwidHlwZVwiKTtcbiAgICB0aGlzLm1kNXN1bSA9IGdldEZpZWxkKGJ1ZmZlckZpZWxkcywgXCJtZDVzdW1cIik7XG4gICAgdGhpcy5tZXNzYWdlRGVmaW5pdGlvbiA9IGdldEZpZWxkKGJ1ZmZlckZpZWxkcywgXCJtZXNzYWdlX2RlZmluaXRpb25cIik7XG4gICAgaWYgKGJ1ZmZlckZpZWxkcy5jYWxsZXJpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGxlcmlkID0gYnVmZmVyRmllbGRzLmNhbGxlcmlkLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChidWZmZXJGaWVsZHMubGF0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sYXRjaGluZyA9IGJ1ZmZlckZpZWxkcy5sYXRjaGluZy50b1N0cmluZygpID09PSBcIjFcIjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VEYXRhIGV4dGVuZHMgUmVjb3JkIHtcbiAgc3RhdGljIG9wY29kZSA9IDI7XG4gIGNvbm46IG51bWJlcjtcbiAgdGltZTogVGltZTtcbiAgZGF0YTogQnVmZmVyO1xuXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogeyBba2V5OiBzdHJpbmddOiBCdWZmZXIgfSwgYnVmZmVyOiBCdWZmZXIpIHtcbiAgICBzdXBlcihmaWVsZHMsIGJ1ZmZlcik7XG4gICAgdGhpcy5jb25uID0gZmllbGRzLmNvbm4ucmVhZFVJbnQzMkxFKDApO1xuICAgIHRoaXMudGltZSA9IGV4dHJhY3RUaW1lKGZpZWxkcy50aW1lLCAwKTtcbiAgICB0aGlzLmRhdGEgPSBidWZmZXI7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluZGV4RGF0YSBleHRlbmRzIFJlY29yZCB7XG4gIHN0YXRpYyBvcGNvZGUgPSA0O1xuICB2ZXI6IG51bWJlcjtcbiAgY29ubjogbnVtYmVyO1xuICBjb3VudDogbnVtYmVyO1xuICBpbmRpY2VzOiBBcnJheTx7IHRpbWU6IFRpbWUsIG9mZnNldDogbnVtYmVyIH0+O1xuXG4gIGNvbnN0cnVjdG9yKGZpZWxkczogeyBba2V5OiBzdHJpbmddOiBCdWZmZXIgfSwgYnVmZmVyOiBCdWZmZXIpIHtcbiAgICBzdXBlcihmaWVsZHMsIGJ1ZmZlcik7XG4gICAgdGhpcy52ZXIgPSBmaWVsZHMudmVyLnJlYWRVSW50MzJMRSgwKTtcbiAgICB0aGlzLmNvbm4gPSBmaWVsZHMuY29ubi5yZWFkVUludDMyTEUoMCk7XG4gICAgdGhpcy5jb3VudCA9IGZpZWxkcy5jb3VudC5yZWFkVUludDMyTEUoMCk7XG5cbiAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuICAgICAgdGhpcy5pbmRpY2VzLnB1c2goe1xuICAgICAgICB0aW1lOiBleHRyYWN0VGltZShidWZmZXIsIGkgKiAxMiksXG4gICAgICAgIG9mZnNldDogYnVmZmVyLnJlYWRVSW50MzJMRShpICogMTIgKyA4KSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2h1bmtJbmZvIGV4dGVuZHMgUmVjb3JkIHtcbiAgc3RhdGljIG9wY29kZSA9IDY7XG4gIHZlcjogbnVtYmVyO1xuICBjaHVua1Bvc2l0aW9uOiBudW1iZXI7XG4gIHN0YXJ0VGltZTogVGltZTtcbiAgZW5kVGltZTogVGltZTtcbiAgY291bnQ6IG51bWJlcjtcbiAgY29ubmVjdGlvbnM6IEFycmF5PHsgY29ubjogbnVtYmVyLCBjb3VudDogbnVtYmVyIH0+O1xuICBuZXh0Q2h1bms6ID9DaHVua0luZm87XG5cbiAgY29uc3RydWN0b3IoZmllbGRzOiB7IFtrZXk6IHN0cmluZ106IEJ1ZmZlciB9LCBidWZmZXI6IEJ1ZmZlcikge1xuICAgIHN1cGVyKGZpZWxkcywgYnVmZmVyKTtcbiAgICB0aGlzLnZlciA9IGZpZWxkcy52ZXIucmVhZFVJbnQzMkxFKDApO1xuICAgIHRoaXMuY2h1bmtQb3NpdGlvbiA9IHJlYWRVSW50NjRMRShmaWVsZHMuY2h1bmtfcG9zKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IGV4dHJhY3RUaW1lKGZpZWxkcy5zdGFydF90aW1lLCAwKTtcbiAgICB0aGlzLmVuZFRpbWUgPSBleHRyYWN0VGltZShmaWVsZHMuZW5kX3RpbWUsIDApO1xuICAgIHRoaXMuY291bnQgPSBmaWVsZHMuY291bnQucmVhZFVJbnQzMkxFKDApO1xuXG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICBjb25uOiBidWZmZXIucmVhZFVJbnQzMkxFKGkgKiA4KSxcbiAgICAgICAgY291bnQ6IGJ1ZmZlci5yZWFkVUludDMyTEUoaSAqIDggKyA0KSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVyXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImhlYXBcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaW50NTNcIik7Il0sInNvdXJjZVJvb3QiOiIifQ==